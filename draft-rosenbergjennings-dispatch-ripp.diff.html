<html><head><title>wdiff draft-rosenbergjennings-dispatch-ripp-old.txt draft-rosenbergjennings-dispatch-ripp-00.txt</title></head><body>
<pre>

Network Working Group                                        <strike><font color='red'>C. Jennings
Internet-Draft                                             Cisco Systems</font></strike>                                       <strong><font color='green'>J. Rosenberg</font></strong>

Intended status: Standards Track                            <strike><font color='red'>J. Rosenberg</font></strike>                             <strong><font color='green'>C. Jennings</font></strong>
Expires: December 25, 2019                                         <strike><font color='red'>Five9</font></strike>                                 <strong><font color='green'>Cisco Systems</font></strong>
                                                           June 23, 2019

                  Real Time Internet Peering Protocol
                draft-rosenbergjennings-dispatch-ripp-00

Abstract

   This document specifies the Realtime Internet Peering Protocol
   (RIPP).  RIPP is used to provide telephony peering between <strike><font color='red'>two
   providers, and is targeted specifically at interconnections between</font></strike> a
   <strike><font color='red'>telephony provider and an application</font></strike> <strong><font color='green'>trunking</font></strong>
   provider (such as a <strong><font color='green'>telco), and a trunking consumer (such as an
   enterprise, cloud PBX provider,</font></strong> cloud contact <strike><font color='red'>center) that wishes to send</font></strike> <strong><font color='green'>center provider,</font></strong> and <strike><font color='red'>receive calls to the
   telephone network.</font></strike> <strong><font color='green'>so
   on).</font></strong>  RIPP is an alternative to <strike><font color='red'>SIP</font></strike> <strong><font color='green'>SIP, SDP</font></strong> and RTP for this use case,
   and is designed to run <strike><font color='red'>ontop</font></strike> <strong><font color='green'>on top</font></strong> of HTTP/3.  Using HTTP/3 allows <strike><font color='red'>application providers</font></strike>
   <strong><font color='green'>trunking consumers</font></strong> to more easily build their applications
   <strike><font color='red'>ontop</font></strike> <strong><font color='green'>on top</font></strong> of
   cloud platforms, such as AWS, Azure and Google Cloud, all of which
   are heavily focused on HTTP based services.  <strong><font color='green'>RIPP also addresses many
   of the challenges of traditional SIP-based trunking.  Most notably,
   it mandates secure caller ID via STIR, and provides automated trunk
   provisioning as a mandatory protocol component.  RIPP supports both
   direct and "BYO" trunk configurations.  Since it runs over HTTP/3, it
   works through NATs and firewalls with the same ease as HTTP does, and
   easily supports load balancing with elastic cluster expansion and
   contraction, including auto-scaling - all because it is nothing more
   than an HTTP application.  RIPP also provides built in mechanisms for
   migrations of calls between RIPP client and server instances,
   enabling failover with call preservation.</font></strong>

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on December 25, 2019.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Background  . . . . . . . . . . . . . . . . . . . . . . .   3
     1.2.  Problem Statement . . . . . . . . . . . . . . . . . . . .   4
     1.3.  Solution  . . . . . . . . . . . . . . . . . . . . . . . .   <strike><font color='red'>4</font></strike>   <strong><font color='green'>5</font></strong>
     1.4.  Why Now?  . . . . . . . . . . . . . . . . . . . . . . . .   5
   2.  Solution Requirements . . . . . . . . . . . . . . . . . . . .   <strike><font color='red'>5</font></strike>   <strong><font color='green'>6</font></strong>
   3.  Design Approaches . . . . . . . . . . . . . . . . . . . . . .   <strike><font color='red'>6</font></strike>   <strong><font color='green'>7</font></strong>
     3.1.  HBH, not E2E  . . . . . . . . . . . . . . . . . . . . . .   <strike><font color='red'>6</font></strike>   <strong><font color='green'>7</font></strong>
     3.2.  Client-Server, not Agent-to-Agent . . . . . . . . . . . .   7
     3.3.  Signaling and Media Together  . . . . . . . . . . . . . .   <strike><font color='red'>7</font></strike>   <strong><font color='green'>8</font></strong>
     3.4.  URIs not IPs  . . . . . . . . . . . . . . . . . . . . . .   8
     3.5.  OAuth not MTLS or private IP  . . . . . . . . . . . . . .   <strike><font color='red'>8</font></strike>   <strong><font color='green'>9</font></strong>
     3.6.  TLS1.3 not SRTP or SIPS . . . . . . . . . . . . . . . . .   9
     3.7.  Authenticated CallerID  . . . . . . . . . . . . . . . . .   <strike><font color='red'>9</font></strike>  <strong><font color='green'>10</font></strong>
     3.8.  Calls Separate from Connections . . . . . . . . . . . . .  10
     3.9.  Path Validation, not ICE  . . . . . . . . . . . . . . . .  <strike><font color='red'>10</font></strike>  <strong><font color='green'>11</font></strong>
   4.  Reference Architecture  . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>10</font></strike>  <strong><font color='green'>11</font></strong>
   5.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>12</font></strike>  <strong><font color='green'>13</font></strong>
   6.  Overview of Operation . . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>13
     6.1.  Discovery and Provisioning</font></strike>  <strong><font color='green'>14
   7.  Example</font></strong> . . . . . . . . . . . . . . .  <strike><font color='red'>13
     6.2.  Initiating Calls</font></strike> . . . . . . . . . . . .  <strong><font color='green'>17
     7.1.  Inbound Call</font></strong>  . . . . . . . .  <strike><font color='red'>14
     6.3.  Establishing the Signaling and Media Transactions</font></strike> . . . .  <strike><font color='red'>15
     6.4.  Terminating and Re-establishing Media and Signaling
           Transactions</font></strike> . . . . . . . . . .  <strong><font color='green'>18
     7.2.  Outbound Call</font></strong> . . . . . . . . . . . .  <strike><font color='red'>17
     6.5.  Media Negotiation</font></strike> . . . . . . . . . .  <strong><font color='green'>18
     7.3.  End of call</font></strong> . . . . . . . . . .  <strike><font color='red'>17
     6.6.  Framing</font></strike> . . . . . . . . . . . . .  <strong><font color='green'>19
   8.  Detailed Behaviours</font></strong> . . . . . . . . . . . .  <strike><font color='red'>17
       6.6.1.  Signaling Framing</font></strike> . . . . . . . . .  <strong><font color='green'>19
     8.1.  Configuration</font></strong> . . . . . . . . .  <strike><font color='red'>18
       6.6.2.  Media Framing</font></strike> . . . . . . . . . . . . .  <strong><font color='green'>19
     8.2.  RIPP Trunk Provisioning</font></strong> . . . . . . .  <strike><font color='red'>18
     6.7.  Signaling - Events</font></strike> . . . . . . . . . .  <strong><font color='green'>20
     8.3.  Capabilities  . .</font></strong> . . . . . . . . .  <strike><font color='red'>19
     6.8.  Signaling State Machine</font></strike> . . . . . . . . . . .  <strong><font color='green'>21
     8.4.  Initiating Calls  . . .</font></strong> . . . . . .  <strike><font color='red'>20
       6.8.1.  Client</font></strike> . . . . . . . . . . .  <strong><font color='green'>23
     8.5.  Establishing the Signaling Byway</font></strong>  . . . . . . . . . . . .  <strike><font color='red'>20
       6.8.2.  Server</font></strike>  <strong><font color='green'>25
     8.6.  The Media Sequence</font></strong>  . . . . . . . . . . . . . . . . . . .  <strong><font color='green'>25
     8.7.  Opening Media Byways</font></strong>  . . . .  <strike><font color='red'>21
     6.9.</font></strike> <strong><font color='green'>. . . . . . . . . . . . . .  26
     8.8.  Sending and Receiving</font></strong> Media . . . . . . . . . . . . . . .  <strong><font color='green'>28
     8.9.  Terminating and Re-establishing Connections and  Byways .  29
     8.10. Signaling - Events  . . .</font></strong> . . . . . . . . . . .  <strike><font color='red'>21
     6.10.</font></strike> <strong><font color='green'>. . . . .  29
     8.11.</font></strong> Call Termination  . . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>23
     6.11.</font></strike>  <strong><font color='green'>31
     8.12.</font></strong> GET Transactions  . . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>23
     6.12.</font></strike>  <strong><font color='green'>31
     8.13.</font></strong> Graceful Call Migration: Server . . . . . . . . . . . . .  <strike><font color='red'>23
     6.13.</font></strike>  <strong><font color='green'>31
     8.14.</font></strong> Graceful Call Migration: Client . . . . . . . . . . . . .  <strike><font color='red'>24
     6.14.</font></strike>  <strong><font color='green'>32
     8.15.</font></strong> Ungraceful Call Migration . . . . . . . . . . . . . . . .  <strike><font color='red'>24
   7.  Detailed Protocol Semantics</font></strike>  <strong><font color='green'>32
   9.  Syntax</font></strong>  . . . . . . . . . . . . . . . . .  <strike><font color='red'>25
   8.  Syntx</font></strike> . . . . . . . . . .  <strong><font color='green'>32
   10. SIP Gateway</font></strong> . . . . . . . . . . . . . . . . . .  <strike><font color='red'>25
   9.  SIP to</font></strike> <strong><font color='green'>. . . . . . .  33
     10.1.</font></strong>  RIPP <strike><font color='red'>Gatewaying</font></strike> <strong><font color='green'>to SIP</font></strong>  . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>25
   10. RIPP to</font></strike> <strong><font color='green'>. . .  33
     10.2.</font></strong>  SIP <strike><font color='red'>Gatewaying</font></strike> <strong><font color='green'>to RIPP</font></strong>  . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>25</font></strike> <strong><font color='green'>. . .  33</font></strong>
   11. <strong><font color='green'>RAML API  . . . . . . . . . . . . . . . . . . . . . . . . . .  33
   12.</font></strong> IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>25
   12.</font></strike>  <strong><font color='green'>36
   13.</font></strong> Security Considerations . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>25
   13.</font></strike>  <strong><font color='green'>36
   14.</font></strong> Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>25</font></strike>  <strong><font color='green'>36
   15. Informative References  . . . . . . . . . . . . . . . . . . .  36</font></strong>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <strike><font color='red'>25</font></strike>  <strong><font color='green'>37</font></strong>

1.  Introduction

1.1.  Background

   Cloud computing platforms, such as those provided by Amazon, Azure,
   and Google, have now become mainstream for the development of
   software applications.  These platforms are targeted at enabling web
   applications, and as such many of their features are based on the
   usage of HTTP.

   One example are HTTP load balancers.  Cloud computing platforms
   provide highly scalable, geographically distributed, redundant load
   balancers.  These load balancers can monitor the state of downstream
   servers and can uniformly distribute load amongst them.  The load
   balancers can compensate for failure of individual nodes and send new
   traffic to other nodes.

   Autoscaling is another example.  The cloud computing platforms can
   automatically add new instances of a server backend, or remove them,
   and automatically configure the load balancers to include them in the
   pool of available servers.

   Yet another example is Kubernetes, which allows web-based
   applications to be deployed into containers (typically Docker), with
   load balancing, scaling, and HTTP request routing.

   Another example are HTTP tracing tools, which facilitate the tracing
   of requests through distributed microservices.  These tools can
   autogenerate sequence diagrams and facilitate in troubleshooting.

   Yet another example are API gateways (such as APIGee and Kong), which
   provide authentication and authorization, provisioning of
   applications, rate limiting, analytics, sandboxing for testing,
   embedded documentation, and so on.

   And yet another example are denial-of-service prevention techniques,
   typically done using BGP peering and re-routing.  Though in principle
   these <strike><font color='red'>technicques</font></strike> <strong><font color='green'>techniques</font></strong> can work for VoIP, they are deployed in conjunction
   with the load balancers which represent the entry point into these
   cloud provider networks.  Consequently, the protections these cloud
   providers offer do not extend to applications which merely use these
   platforms for virtual machines.

   A more recent technology are service meshes, such as Istio, which
   utilize sidecar HTTP proxies to facilitate inter-service
   communications.  These systems come with robust control planes which
   enable additional routing features, such as canary deploys,
   percentage based routing, and so on.

1.2.  Problem Statement

   Unfortunately, there are many applications being deployed into these
   cloud platforms which require interconnection with the public
   switched telephone network (PSTN).  Examples of such applications
   include cloud PBXs, cloud contact centers, cloud meetings
   applications, and so on.  Furthermore, commerce websites would like
   to allow customers to call into the telephone network for customer
   support.

   In order for these applications to connect to the PSTN, they
   typically deploy <strike><font color='red'>SIP-based</font></strike> <strong><font color='green'>Session Initiation Protocol (SIP) [RFC3261] based</font></strong>
   servers - SBCs, SIP proxies, and softswitches, to provide this
   interconnection.  Unfortunately, SIP based applications cannot make
   use of the many capabilities these cloud platforms afford to HTTP
   based applications.  These SIP servers are usually deployed on bare
   metal or VMs at best.  Application developers must build their own
   load balancing, HA, failover, clustering, security, and scaling
   technologies, rather than using the capabilities of these platforms.

   This has creating a barrier to entry, particularly for applications
   such as websites which are not expert in VoIP technologies.
   Furthermore, it has meant that VoIP applications have been unable to
   take advantage of the many technology improvements that have come to
   networking and protocol design since the publication of RFC 3261 in
   2002.

   <strong><font color='green'>In addition, SIP trunking has suffered from complex provisioning
   operations, oftentimes requiring the exchange of static IPs and
   ports.  These operations are almost never self-service and
   consequently, SIP trunk turn ups can take weeks.  Finally, perhaps
   the biggest challenge with SIP trunking has been its abuse for
   injecting robocalls.</font></strong>

1.3.  Solution

   The goal of RIPP is to enable one administrative domain to send and
   receive voice calls with another domain.  In this regard, RIPP
   replaces the usage of SIP, SDP <strong><font color='green'>offer/answer [RFC3264]</font></strong> and RTP
   <strong><font color='green'>[RFC3550]</font></strong> for this particular use case.  RIPP does not actually
   deprecate or replace SIP itself, as it covers only a small subset of
   the broader functionality that SIP provides.  It is designed to be
   the minimum protocol required to interconnect
   <strike><font color='red'>voice.</font></strike> <strong><font color='green'>voice between a
   trunking provider and a domain wishing to access trunking services.</font></strong>

   In order to make use of new HTTP based technologies as described
   above, RIPP <strong><font color='green'>uses HTTP/3 [I-D.ietf-quic-http], but</font></strong> is not an extension
   to <strike><font color='red'>HTTP3, but rather is a usage of</font></strike> it.  The goal is to ride the coattails of advancement in HTTP
   based technologies without requiring them to do anything special for
   the benefit of VoIP.  <strong><font color='green'>This means that RIPP inherits the benefits of
   classic HTTP deployments - easy load balancing, easy expansion and
   contraction of clusters (including auto-scaling), standard techniques
   for encryption, authentication, and denial-of-service prevention, and
   so on.

   RIPP also includes a built-in mechanism for provisioning, as a
   mandatory component of the specification.  This enables RIPP trunks
   to be self-provisioned through web portals, and instantly turned on
   in production.  This will help accelerate the adoption of
   telecommunications services across the web.</font></strong>

1.4.  Why Now?

   The idea of <strike><font color='red'>reconverging</font></strike> <strong><font color='green'>re-converging</font></strong> HTTP and SIP is certainly not new, and
   indeed has been discussed in the hallways of IETF for many years.
   However, several significant limitations made this previously
   <strike><font color='red'>infeasibile:</font></strike>
   <strong><font color='green'>infeasible:</font></strong>

   1.  HTTP utilized TCP, which meant that it created head-of-line
       blocking which would delay lost packets rather than just discard
       them.  This will often provide intolerable latency for VoIP.

   2.  HTTP was request response, allowing the client to send requests
       and receive a response.  There as no way for a server to
       asynchronously send information to the client in an easy fashion.

   HTTP2 <strong><font color='green'>[RFC7540]</font></strong> addressed the second of these with the introduction
   of pushes and long running requests.  However, its usage of TCP was
   still a problem.  This has finally been addressed with the arrival of
   QUIC <strong><font color='green'>[I-D.ietf-quic-transport]</font></strong> and HTTP3.  QUIC is based on UDP, and
   it introduces the concept of a
   <strike><font color='red'>stream.</font></strike> <strong><font color='green'>stream that can be set up with zero
   RTT.</font></strong>  These streams are carried over UDP, and though are still
   reliable, there is no head of line blocking across streams.  This
   change has made it possible for HTTP to support VoIP applications.

2.  Solution Requirements

   The protocol defined here is based on the following requirements:

   REQ1: The solution shall not require extensions or modifications to
   HTTP3.

   REQ2: The solution shall work with both L4 and L7 HTTP load balancers

   REQ3: The solution shall work in ways that are compatible with best
   practices for load balancers and proxies supporting HTTP3, and not
   require any special changes to these load balancers in order to
   function.

   REQ4: The solution <strong><font color='green'>should hide the number of servers behind the load
   balancer, allow the addition or removal of servers from the cluster
   at will, and not expose any of this information to the peer

   REQ5: The solution</font></strong> shall enable the usage of autoscaling technologies
   used in cloud <strike><font color='red'>platforms

   REQ4:</font></strike> <strong><font color='green'>platforms, without any special consideration for RIPP -
   its just a web app

   REQ6:</font></strong> The solution shall provide call <strike><font color='red'>reliability</font></strike> <strong><font color='green'>preservation</font></strong> in the face of
   failures of the server or <strike><font color='red'>client
   REQ5:</font></strike> <strong><font color='green'>client.  It is acceptable for a brief blip
   of media due to transient packet loss, but thats it

   REQ7:</font></strong> The solution shall support built-in migration, allowing a
   server to quickly shed load in order to be restarted or upgraded,
   without any impact to calls in progress

   <strike><font color='red'>REQ6:</font></strike>

   <strong><font color='green'>REQ8:</font></strong> The solution will be easy to interoperate with SIP

   <strike><font color='red'>REQ7:</font></strike>

   <strong><font color='green'>REQ9:</font></strong> The solution shall be incrementally deployable - specifically
   it must be designed for easy implementation by SBCs and easy
   deployment by PSTN termination and origination providers who do not
   utilize cloud platforms

   <strike><font color='red'>REQ8:</font></strike>

   <strong><font color='green'>REQ10:</font></strong> The solution shall build-in callerID security and protections
   from robocalling at the outset

   <strike><font color='red'>REQ9:</font></strike>
   <strong><font color='green'>REQ11:</font></strong> The solution shall provide low latency for media

   <strike><font color='red'>REQ10:</font></strike>

   <strong><font color='green'>REQ12:</font></strong> The solution shall support only audio, but be extensible to
   video or other media in the future

   <strong><font color='green'>REQ13: The solution must support secure caller ID out of the gate and
   not inherit any of the insecure techniques used with SIP

   REQ14: The solution shall include mandatory-to-implement provisioning
   operations</font></strong>

3.  Design Approaches

   To meet the requirements stated above, RIPP makes several fundamental
   changes compared to SIP.  These changes, and their motivations, are
   described in the sections below.

3.1.  HBH, not E2E

   SIP was designed as an end-to-end protocol.  As such, it explicitly
   incorporates features which presume the existence of a network of
   elements - proxies and registrars in particular.  SIP provides many
   features to facilitate this - Via headers, record-routing, and so on.

   HTTP on the other hand - is strictly a hop-by-hop technology.  Though
   it does support the notion of proxies (ala the CONNECT method for
   reverse proxies), the protocol is fundamentally designed to be
   between a client and an authoritative server.  What happens beyond
   that authoritative server is beyond the scope of HTTP, and can (and
   often does) include additional HTTP transactions.

   Consequently, in order to reside within HTTP, RIPP follows the same
   pattern and only concerns itself with HBH <strike><font color='red'>behaviors.</font></strike> <strong><font color='green'>behaviours.</font></strong>  Like HTTP, a
   RIPP server can of course act as a RIPP client and further connect
   calls to downstream elements.  However, such behavior requires no
   additional specification and is therefore not discussed by RIPP.

3.2.  Client-Server, not Agent-to-Agent

   SIP is based fundamentally on the User Agent, and describes the
   communications between a pair of user agents.  Either user agent can
   initiate requests towards the other.  SIP defines the traditional
   role of client and server as bound to a specific transaction.

   HTTP does not operate this way.  In HTTP, one entity is a client, and
   the other is a server.  There is no way for the server to send
   messages asynchronously towards the client.  HTTP3 does enable two
   distinct techniques that facilitate server messaging towards the
   client.  But to use them, RIPP must abide by HTTP3 rules, and that
   means distinct roles for clients and servers.  Clients must always
   initiate connections and send requests, not servers.

   To handle this RIPP, specifies that the <strike><font color='red'>calling</font></strike> domain <strong><font color='green'>associated with the
   caller</font></strong> implements the RIPP client, and the domain receiving the calls
   is the RIPP server.  For any particular call, the roles of client and
   server do not change.  To facilitate calls in either direction, a
   domain can implement both RIPP client and RIPP server roles.
   However, there is no relationship between the two directions.

3.3.  Signaling and Media Together

   One of the most fundamental design properties of SIP was the
   separation of <strike><font color='red'>signaling</font></strike> <strong><font color='green'>signalling</font></strong> and media.  This was fundamental to the
   success of SIP, since it enabled high quality, low latency media
   between endpoints inside of an enterprise or consumer domain.

   This design technique is quite hard to translate to HTTP, especially
   when considering load balancing and scaling techniques.  HTTP load
   balancing is effective because it treats each request/response pair
   as an independent action which can route to any number of backends.
   In essence, the request/response transaction is atomic, and
   consequentially RIPP needs to operate this way as well.

   Though SIP envisioned that <strike><font color='red'>signaling</font></strike> <strong><font color='green'>signalling</font></strong> and media separation would also
   apply to inter-domain calls, in practice this has not happened.
   Inter-domain interconnect - used primarily for interconnection with
   the PSTN - is done traditionally with SBCs which terminate and re-
   originate media.  Since this specification is targeted solely at
   these peering use cases, RIPP fundamentally combines <strike><font color='red'>signaling</font></strike> <strong><font color='green'>signalling</font></strong> and
   media together on the same connection.  To ensure low latency, it
   uses multiple independent request/response transactions - each
   running in parallel over unique QUIC streams - to transmit media.

3.4.  URIs not IPs

   SIP is full of IP addresses and ports.  They are contained in Via
   headers, in Route and Record-Route headers.  In SDP.  In Contact
   headers.  The usage of IPs is one of the main reasons why SIP is so
   difficult to deploy into cloud platforms.  These platforms are based
   on the behavior of HTTP which has been baed on TCP connections and
   therefore done most of its routing at the connection layer, and not
   the IP layer.

   Furthermore, modern cloud platforms are full of NATs and private IP
   space, making them <strike><font color='red'>inhospitale</font></strike> <strong><font color='green'>inhospitable</font></strong> to SIP based applications which still
   struggle with NAT traversal.

   HTTP of course does not suffer from this.  In general, "addressing",
   to the degree it exists at all, is done with HTTP URIs.  RIPP follows
   this pattern.  RIPP - as an application <strike><font color='red'>ontop</font></strike> <strong><font color='green'>on top</font></strong> of HTTP3 - does not
   use or convey any IP addresses or ports.  <strong><font color='green'>Furthermore, the client
   never provides addressing to the server - all traffic is sent in the
   reverse direction over the connection.</font></strong>

3.5.  OAuth not MTLS or private IP

   When used in peering arrangements today, <strike><font color='red'>authentiation</font></strike> <strong><font color='green'>authentication</font></strong> for the SIP
   connections is typically done using mutual TLS.  It is also often the
   case that security is done at the IP layer, and sometimes even via
   dedicated MPLS connections which <strike><font color='red'>requre pre-proivisioning.</font></strike> <strong><font color='green'>require pre-provisioning.</font></strong>
   Unfortunately, these techniques are quite incompatible with how
   modern cloud platforms work.

   HTTP - due to its client-server nature, uses asymmetric <strike><font color='red'>technicques</font></strike> <strong><font color='green'>techniques</font></strong>
   for authentication.  Most notably, certificate based authentication
   is done by the client to verify that it is speaking to the server it
   thinks it should be speaking to.  For the server to identify the
   client, modern platforms make use of OAuth2.0.  Though OAuth is not
   actually an authentication protocol, the use of OAuth has allowed
   authentication to be done out of band via separate login servers
   which produce OAuth tokens which can then be used for authentication
   of the client.

   Consequently, RIPP follows this same approach.  For each call, one
   domain acts as the client, and the other, as the server.  When acting
   as a server, the domain authenticates itself with TLS and verifies
   the client with OAuth tokens.  For calls in the reverse direction,
   the roles are reversed.

   <strike><font color='red'>Consequently, if two domains want to be able</font></strike>

   <strong><font color='green'>To make it possible</font></strong> to <strike><font color='red'>send</font></strike> <strong><font color='green'>easily pass</font></strong> calls <strike><font color='red'>to each
   other</font></strike> in <strike><font color='red'>either direction,</font></strike> both <strike><font color='red'>domains must acquire Oauth tokens
   valid for placing calls</font></strike> <strong><font color='green'>directions, RIPP
   allows one domain</font></strong> to <strong><font color='green'>act as</font></strong> the <strike><font color='red'>other,</font></strike> <strong><font color='green'>customer of another, the trunking
   provider.  The customer domain authenticates with the provider</font></strong> and <strike><font color='red'>both domains must obtain</font></strike>
   <strong><font color='green'>obtains an OAuth token using</font></strong> traditional <strike><font color='red'>web TLS certificates</font></strike> <strong><font color='green'>techniques.  RIPP then
   allows the customer domain</font></strong> to <strike><font color='red'>prove their server identities</font></strike> <strong><font color='green'>automatically create a bearer token for
   inbound calls and pass it</font></strong> to the <strike><font color='red'>other.</font></strike> <strong><font color='green'>provider.</font></strong>

3.6.  TLS1.3 not SRTP or SIPS

   o  CFJ - I have some preference for just saying TLS without a version
      as some of the SP are looking at not moving to TLS 1.3 and staying
      on 1.2 because it breaks their current TLS accelerator solutions

   SIP has provided encryption of both <strike><font color='red'>signaling</font></strike> <strong><font color='green'>signalling</font></strong> and media, through the
   usage of SIP over TLS and SIPS, and SRTP, respectively.
   Unfortunately, these have not been widely deployed.  The E2E nature
   of SRTP has made keying an ongoing challenge, with multiple
   technologies developed over the years.  SIP itself has seen greater
   uptake of TLS transport, but this remains uncommon largely due to the
   commonality of private IP peering as an alternative.

   Because of the HBH nature of RIPP, security is done fundamentally at
   the connection level - identically to HTTP.  Since media is also
   carrier over the HTTP connection, both <strike><font color='red'>signaling</font></strike> <strong><font color='green'>signalling</font></strong> and media are
   covered by the connection security provided by HTTP3 - which is
   TLS1.3.

   Because of the mandatory usage of TLS1.3 with HTTP3, and the expected
   widespread deployment of HTTP3, running VoIP <strike><font color='red'>ontop</font></strike> <strong><font color='green'>on top</font></strong> of HTTP3 will
   bring built-in encryption of media and <strike><font color='red'>signaling</font></strike> <strong><font color='green'>signalling</font></strong> between peering
   domains, which is a notable improvement over the current deployment
   situation.  It is also necessary in order to utilize HTTP3.

   Because of this, RIPP does not support SRTP.  If a client receives a
   SIP call with SRTP, it must terminate the SRTP and decrypt media
   before sending it over RIPP.  This matches existing practice in any
   case.

   E2E media believers - fire away!

   o  CFJ - I think I would point out this is about PSTN interconnect
      and PSTN is not going E2E.

3.7.  Authenticated CallerID

   Robocalling is seeing a dramatic rise in volume, and efforts to
   combat it continue.  One of the causes of this problem is the ease of
   which SIP enables one domain to <strike><font color='red'>intiate</font></strike> <strong><font color='green'>initiate</font></strong> calls to another domain
   without authenticated caller ID.

   With RIPP, we remedy this by requiring the client and servers to
   implement STIR.  Since RIPP is meant for peering between providers
   (and not client-to-server connections), STIR is applicable.  RIPP
   clients must either insert a signed passport, or pass one through if
   it exists.  Similarly, RIPP servers must act as verifying parties and
   reject any calls that omit a passport.

3.8.  Calls Separate from Connections

   In SIP, there is a fuzzy relationship between calls and connections.
   In some cases, connection failures cause call terminations, and vice
   a versa.

   HTTP, on the <strike><font color='red'>otherhand,</font></strike> <strong><font color='green'>other hand,</font></strong> very clearly separates the state of the
   resource being manipulated, with the state of the HTTP connection
   used to manipulate it.  This design principle is inherited by RIPP.
   Consequently, call state on both client and server exist
   independently from the connections which manipulate them.  This
   allows for greater availability my enabling connections for the same
   call to move between machines in the case of failures.

3.9.  Path Validation, not ICE

   HTTP3 is designed to work through NAT as a client-server protocol.
   It has built in techniques for dealing with NAT <strike><font color='red'>rebindings,</font></strike> <strong><font color='green'>re-bindings,</font></strong> IP
   address changes due to a client moving between networks (e.g., wifi
   to cellular data).  It has built in path validation that ensures that
   HTTP cannot be used for amplification attacks.

   SIP has, over the years, solved these problems to some degree, but
   not efficiently nor completely.  To work with HTTP, RIPP must utilize
   the HTTP approaches for these problems.  Consequently, RIPP does not
   utilize ICE and has no specific considerations for NAT traversal, as
   these are handled by HTTP3 itself.

4.  Reference Architecture

   The RIPP reference architecture is shown in Figure 1.

                 <strong><font color='green'>Trunk Provider             Trunk Consumer

                                 Calls
                +-------------+  From      +-------------+
                |             |  A to B    |             |
                |             |            |             |
                |  Client     | +--------&gt; |  Server     |
                |             |            |             |
                |             |            |             |
                +-------------+            +-------------+

                                Calls
                +-------------+ From       +-------------+
                |             | B to A     |             |
                |             |            |             |
                |  Server     | &lt;--------+ |  Client     |
                |             |            |             |
                |             |            |             |
                +-------------+            +-------------+
   RIPP is used between a RIPP trunk provider and a RIPP trunk consumer.
   Both entities implement the RIPP client and RIPP server roles; the
   latter to receive calls, and the former to send them.

   RIPP is also designed such that all communications between the a RIPP
   client and the RIPP server can easily sit behind a typical HTTP load
   balancer, as shown below:</font></strong>

                                                    +------------+
                                                    |            |
                                                    |  RIPP      |
                                                   &gt;|  Server    |
                                                  / |            |
                                                 /  |            |
                                                /   +------------+
                                               /
                                              /
                                             /
                                            /
                            +---------+    /
                            |         |   /
         +------------+     |         |  /          +------------+
         |            |     |         | /           |            |
         | RIPP       |     |  <strike><font color='red'>L4/L7</font></strike>  <strong><font color='green'>HTTP</font></strong>   |/            |  RIPP      |
         | Client     |----&gt;|  LB     | -----------&gt;|  Server    |
         |            |     |         |\            |            |
         |            |     |         | \           |            |
         +------------+     |         |  \          +------------+
                            +---------+   \
                                           \
                                            \
                                             \
                                              \
                                               \    +------------+
                                                \   |            |
                                                 \  |  RIPP      |
                                                  &gt; |  Server    |
                                                    |            |
                                                    |            |
                                                    +------------+

   <strike><font color='red'>A RIPP client is an HTTP3</font></strike>

   <strong><font color='green'>Since both the trunk provider and trunk consumer implement the</font></strong> client <strike><font color='red'>that wishes to initiate</font></strike>
   <strong><font color='green'>and server roles, both entities will typically have</font></strong> a <strike><font color='red'>call</font></strike> <strong><font color='green'>load balancer
   used</font></strong> to <strike><font color='red'>a
   user in another administrative domain.  To do that, it initiates an
   HTTP3 connection, which will often (though it</font></strike> <strong><font color='green'>receive incoming calls.  This</font></strong> is not <strike><font color='red'>required to)
   terminate on one or more L4 or L7 HTTP</font></strike> <strong><font color='green'>required, of course.  It
   is worth restating that this</font></strong> load <strike><font color='red'>balancers.  Using nothing
   more than traditional</font></strike> <strong><font color='green'>balancer is NOT specific to RIPP -
   it is any off-the-shelf</font></strong> HTTP load <strike><font color='red'>balancing techniques, the connection
   terminates on one of several</font></strike> <strong><font color='green'>balancer which supports HTTP/3.  No
   specific support for</font></strong> RIPP <strike><font color='red'>servers that sit behind the load
   balancer.</font></strike> <strong><font color='green'>is required.  RIPP is just a usage of HTTP.</font></strong>

   Because RIPP clients and servers are nothing more than HTTP3
   applications, the behavior or RIPP is specified <strike><font color='red'>entirey</font></strike> <strong><font color='green'>entirely</font></strong> by
   describing how various RIPP procedures map to the core HTTP3
   primitives available to applications - opening connections, closing
   connections, sending requests and responses, receiving requests and
   responses, and setting header <strike><font color='red'>fields.</font></strike> <strong><font color='green'>fields and bodies.</font></strong>  That's it.

   <strike><font color='red'>When two domains wish to exchange calls in both directions, they
   implement both the HTTP3 client and server roles.  We refer to this
   as fluid HTTP - since either domain can act as either client, or
   server, depending on the need.  Fluid HTTP is shown in Figure 2:

                  Domain A                    Domain B

                                 Calls
                +-------------+  From      +-------------+
                |             |  A to B    |             |
                |             |            |             |
                |  Client     | +--------&gt; |  Server     |
                |             |            |             |
                |             |            |             |
                +-------------+            +-------------+

                                Calls
                +-------------+ From       +-------------+
                |             | B to A     |             |
                |             |            |             |
                |  Server     | &lt;--------+ |  Client     |
                |             |            |             |
                |             |            |             |
                +-------------+            +-------------+</font></strike>

5.  Terminology

   This specification follows the terminology of HTTP3 - specifically:

   RIPP Client: The entity that initiates a call, by acting as an HTTP
   client.

   RIPP Server: The entity that receives a call, by acting as an HTTP
   server.

   RIPP Connection: An HTTP connection between a RIPP client and RIPP
   server.

   RIPP Endpoint: Either a RIPP client or RIPP server.

   RIPP Peer: An endpoint.  When discussing a particular endpoint,
   "peer" refers to the endpoint that is remote to the primary subject
   of discussion.

   <strike><font color='red'>Call:</font></strike>

   <strong><font color='green'>This specification defines the following additional terms:

   RIPP Trunk:</font></strong> A <strike><font color='red'>VoIP session established by</font></strike> <strong><font color='green'>container for calls between</font></strong> a <strong><font color='green'>trunking provider and
   trunking consumer.  A</font></strong> RIPP <strike><font color='red'>client for</font></strike> <strong><font color='green'>trunk is identified by an HTTP URI hosted
   by</font></strong> the <strike><font color='red'>purposes</font></strike> <strong><font color='green'>trunking provider.  RIPP trunks act as a unit</font></strong> of
   <strike><font color='red'>exchanging audio</font></strike> <strong><font color='green'>policy</font></strong> and <strike><font color='red'>signaling information.

   RIPP Domain: An administrative domain that can implement</font></strike>
   <strong><font color='green'>capabilities, including rules such as rate limits, allowed phone
   numbers, and so on.

   Call: A VoIP session established by</font></strong> a RIPP
   <strike><font color='red'>client, RIPP server, or both,</font></strike> <strong><font color='green'>client</font></strong> for the purposes of <strike><font color='red'>making</font></strike>
   <strong><font color='green'>exchanging audio</font></strong> and
   <strike><font color='red'>receiving calls.

   Originating Domain: The domain that initiates</font></strike> <strong><font color='green'>signalling information.  A call is always
   associated with</font></strong> a <strike><font color='red'>call, therefore
   acting as an HTTP and</font></strike> RIPP <strike><font color='red'>client.

   Terminating Domain: The domain</font></strike> <strong><font color='green'>trunk.

   Trunking Consumer: An administrative entity</font></strong> that <strike><font color='red'>receives a call, therefore acting
   as an HTTP and RIPP server.

6.  Overview of Operation

   This section provides an overview of</font></strike> <strong><font color='green'>utilizes trunking
   services from</font></strong> the <strike><font color='red'>operation of RIPP.

6.1.  Discovery</font></strike> <strong><font color='green'>trunking provider.  The relationship between the
   trunking consumer and trunking provider is static</font></strong> and <strike><font color='red'>Provisioning

   RIPP</font></strike> does not <strike><font color='red'>provide any technique for discovery.  It is assumed
   that peering is arranged bilaterally through some out of bands means.
   For example, a RIPP domain can offer a web site through which
   customers can order termination services.  This website can provide
   the RIPP client domain with the information needed</font></strike> <strong><font color='green'>vary
   from call</font></strong> to <strike><font color='red'>inject calls
   into that domain.  For bidirectional peering arrangements, each side</font></strike> <strong><font color='green'>call. (e.g., Verizon</font></strong> would <strike><font color='red'>need to perform this function independently.

   Automated techniques for provisioning bidirecitonal peering
   relationships are beyond</font></strike> <strong><font color='green'>be</font></strong> the <strike><font color='red'>scope of this specification.

   Two pieces -</font></strike> <strong><font color='green'>trunking provider to
   an enterprise,</font></strong> and <strike><font color='red'>only two pieces</font></strike> <strong><font color='green'>the enterprise would be the trunking customer</font></strong> of <strike><font color='red'>information - are required for</font></strike>
   <strong><font color='green'>Verizon.  A trunking consumer implements</font></strong> a <strong><font color='green'>RIPP</font></strong> client <strike><font color='red'>domain</font></strike> to initiate
   calls to <strong><font color='green'>the trunking provider, and</font></strong> a <strong><font color='green'>RIPP</font></strong> server <strike><font color='red'>domain:

   1.</font></strike> <strong><font color='green'>to receive them.

   Trunking Provider:</font></strong> The <strike><font color='red'>root URI for placing calls,

   2.  A valid OAuth token

   It is RECOMMENDED</font></strike> <strong><font color='green'>administrative entity</font></strong> that <strike><font color='red'>these be provided via a website operated by</font></strike> <strong><font color='green'>provides telephony
   trunking services to</font></strong> the <strike><font color='red'>terminating domain.  This also means</font></strike> <strong><font color='green'>trunking consumer.  The relationship between</font></strong>
   the <strike><font color='red'>process of
   authentication of</font></strike> <strong><font color='green'>trunking consumer and trunking provider is static and does not
   vary from call to call. (e.g., Verizon would be</font></strong> the <strike><font color='red'>originating domain</font></strike> <strong><font color='green'>trunking provider</font></strong>
   to <strong><font color='green'>an enterprise, and</font></strong> the <strike><font color='red'>terminating domai is
   fully outside</font></strike> <strong><font color='green'>enterprise would be</font></strong> the <strike><font color='red'>scope</font></strike> <strong><font color='green'>trunking customer</font></strong>
   of <strike><font color='red'>this spceification,</font></strike> <strong><font color='green'>Verizon.  The trunking provider implements a RIPP server to
   receive calls from the trunking consumer,</font></strong> and <strike><font color='red'>can follow any
   desired technique by</font></strike> <strong><font color='green'>a RIPP client to send
   calls to</font></strong> the <strike><font color='red'>terminating domain that ultimately results
   in</font></strike> <strong><font color='green'>trunking consumer

   Trunking Customer: The administrative entity which purchases trunking
   services from</font></strong> the <strike><font color='red'>issuance of an OAuth token.</font></strike> <strong><font color='green'>trunking provider.</font></strong>  The <strike><font color='red'>root URI MUST</font></strike> <strong><font color='green'>trunking customer may</font></strong> be
   <strong><font color='green'>the same as the trunking consumer - such as an enterprise purchasing
   and then consuming trunking services from</font></strong> a <strike><font color='red'>valid HTTPS URI.  The terminating domain MUST</font></strike> <strong><font color='green'>telco.  Or, it can</font></strong> be <strike><font color='red'>compliant with HTTP3 in processing requests.  The root URI MAY
   contain</font></strike>
   <strong><font color='green'>different - such as an enterprise purchasing trunking services from</font></strong> a <strike><font color='red'>path component, though this is optional.

   All requests to create</font></strike>
   <strong><font color='green'>telco, and then authorizing</font></strong> a <strike><font color='red'>new call are initiated</font></strike> <strong><font color='green'>cloud PBX or cloud contact center
   provider to consume those trunking services on their behalf.

   RIPP Trunk URI: An HTTP URI hosted</font></strong> by the <strike><font color='red'>client towards
   this URI.

   As an example,</font></strike> <strong><font color='green'>trunking provider, which
   represents RIPP trunk.

   RIPP Trunk Consumer URI: An HTTP URI hosted by</font></strong> the <strike><font color='red'>following is</font></strike> <strong><font color='green'>trunking consumer,
   used to receive calls from the trunking provider associated with</font></strong> a <strike><font color='red'>valid</font></strike>
   <strong><font color='green'>specific</font></strong> RIPP <strike><font color='red'>root URI:

   &lt;https://telco.com/calls&gt;

6.2.  Initiating Calls

   To initiate</font></strike> <strong><font color='green'>trunk.

   Byway: A bidirectional byte stream between</font></strong> a <strike><font color='red'>new call,</font></strike> <strong><font color='green'>RIPR provide and
   consumer.  A Byway passes its data through</font></strong> a <strike><font color='red'>client initiates</font></strike> <strong><font color='green'>long-running HTTP
   request and</font></strong> a <strike><font color='red'>connection to the root
   URI</font></strike> <strong><font color='green'>long-running HTTP response.  Byways are used</font></strong> for <strike><font color='red'>the domain to which it wishes to place the call.  This MUST
   be an HTTP3 request,</font></strike>
   <strong><font color='green'>signalling</font></strong> and <strike><font color='red'>MUST be made to</font></strike> <strong><font color='green'>media.

6.  Overview of Operation

   RIPP begins with a configuration phase.  This configuration phase
   occurs when</font></strong> an <strike><font color='red'>HTTPS URI.  If the</font></strike> <strong><font color='green'>OAuth2.0</font></strong> client
   <strike><font color='red'>already has</font></strike> <strong><font color='green'>application (such as</font></strong> a <strike><font color='red'>connection open</font></strike> <strong><font color='green'>softswitch,
   cloud PBX, cloud contact center, etc) wishes to enable trunking
   customers</font></strong> to <strong><font color='green'>provision RIPP trunks against a trunking provider.  The
   trunking provider acts as</font></strong> the <strike><font color='red'>server, it MAY reuse that
   connection.  It</font></strike> <strong><font color='green'>resource provider in OAuth2.0 parlance.
   Consequently, The configuration phase</font></strong> is <strike><font color='red'>RECOMMENDED that clients keep their connections
   open</font></strike> <strong><font color='green'>identical</font></strong> to the <strike><font color='red'>server,</font></strike> <strong><font color='green'>way</font></strong> in <strike><font color='red'>order to speed up call setup delays.
   Furthermore, it is RECOMMENDED that the underlying HTTP</font></strike>
   <strong><font color='green'>which</font></strong> client
   <strike><font color='red'>implementation make use of 0-RTT connections to further improve call
   setup times</font></strike> <strong><font color='green'>applications register with resource providers</font></strong> in <strike><font color='red'>cases where</font></strike>
   <strong><font color='green'>OAuth2.0,</font></strong> the <strike><font color='red'>HTTP connection</font></strike> <strong><font color='green'>details of which are beyond the scope of this
   specification, but expected to follow existing best practices used by
   web applications.

   The next step is provisioning.  Once a trunking customer</font></strong> has <strike><font color='red'>been dropped.

   To place</font></strike>
   <strong><font color='green'>purchased services from a trunking provider,</font></strong> the <strike><font color='red'>call,</font></strike> <strong><font color='green'>trunking customer
   can perform provisioning.  Provisioning is</font></strong> the <strong><font color='green'>process by which a
   trunking customer connects a</font></strong> RIPP <strike><font color='red'>client MUST initiate</font></strike> <strong><font color='green'>trunk from</font></strong> a <strike><font color='red'>POST request</font></strike> <strong><font color='green'>trunking provider</font></strong> to
   <strike><font color='red'>this URI.  It MUST append the root URI with</font></strike>
   <strong><font color='green'>trunking consumer.  Provisioning is accomplished using
   OAuth2.0 code authorization techniques.  In</font></strong> the <strike><font color='red'>attribute "newcall".
   For example:

   POST &lt;https://telco.com/calls?newcall&gt;

   This request MUST contain</font></strike> <strong><font color='green'>case of RIPP,</font></strong> the
   OAuth <strike><font color='red'>token that</font></strike> <strong><font color='green'>resource owner is</font></strong> the <strong><font color='green'>trunking customer.  The OAuth</font></strong> client <strike><font color='red'>has
   obtained out-of-band.</font></strike> <strong><font color='green'>is
   the RIPP implementation within the trunking consumer.</font></strong>  The <strong><font color='green'>resource</font></strong>
   server <strike><font color='red'>will validate</font></strike> <strong><font color='green'>is</font></strong> the <strike><font color='red'>OAuth token, authorize</font></strike> <strong><font color='green'>RIPP implementation in</font></strong> the <strike><font color='red'>creation of</font></strike> <strong><font color='green'>trunking provider.

   To provision</font></strong> a
   <strike><font color='red'>new call, and then either accept or reject the request.  If accepted,
   it indicates that</font></strike> <strong><font color='green'>RIPP trunk,</font></strong> the <strike><font color='red'>server is willing to create this call.  The
   server MUST return</font></strike> <strong><font color='green'>trunking customer will visit</font></strong> a <strike><font color='red'>201 Created response,</font></strike> <strong><font color='green'>web
   page hosted by the trunking consumer,</font></strong> and <strike><font color='red'>MUST include</font></strike> <strong><font color='green'>typically click on</font></strong> a
   <strike><font color='red'>Location header field containing an HTTPS URI which identifies</font></strike> <strong><font color='green'>button
   labeled with their trunking provider.  This will begin</font></strong> the
   <strike><font color='red'>call that has been created.</font></strike> <strong><font color='green'>OAuth 2
   authorization code flow.</font></strong>  The <strike><font color='red'>URI identifying</font></strike> <strong><font color='green'>trunking customer will authenticate
   with</font></strong> the <strike><font color='red'>call MUST
   include a path segment which contains a type 4 UUID, ensuring that
   call identifiers are unique across time</font></strike> <strong><font color='green'>trunking provider.  The trunking provider authorizes the
   access, generate an authorization code,</font></strong> and <strike><font color='red'>space.

   An example URI that identifies</font></strike> <strong><font color='green'>generates</font></strong> a <strike><font color='red'>call is:

   &lt;https://telco.com/calls/id/ha8d7f6fso29s88clzopapie8x8c&gt;</font></strike> <strong><font color='green'>RIPP trunk
   URI.</font></strong>  The <strike><font color='red'>server MAY include an HTTP session cookie</font></strike> <strong><font color='green'>RIPP trunk URI is included in a new OAuth parameter defined
   by this specification,and is returned as a parameter</font></strong> in the <strike><font color='red'>201</font></strike>
   <strong><font color='green'>authorization</font></strong> response.  The <strike><font color='red'>usage of an HTTP URI to identify</font></strike> <strong><font color='green'>trunking consumer trades</font></strong> the <strike><font color='red'>call itself, combined</font></strike>
   <strong><font color='green'>authorization code for a refresh and access token, and stores the SIP
   Trunk URI.  Finally, the trunking consumer mints a bearer token
   associated</font></strong> with
   <strike><font color='red'>session cookies, gives</font></strike> the <strike><font color='red'>terminating</font></strike> <strong><font color='green'>new</font></strong> RIPP <strike><font color='red'>domain</font></strike> <strong><font color='green'>trunk, and also mints</font></strong> a <strike><font color='red'>great deal of
   flexibility in how it manages state</font></strike> <strong><font color='green'>RIPP trunk
   consumer URI</font></strong> for <strong><font color='green'>receiving calls from</font></strong> the <strike><font color='red'>call.  In traditional
   softswitch designs, call and media state is held in-memory in</font></strike> <strong><font color='green'>provider on this trunk.
   Both of these are passed to</font></strong> the
   <strike><font color='red'>server and not placed into databases.  In such a design,</font></strike> <strong><font color='green'>trunking provider via</font></strong> a <strike><font color='red'>RIPP
   server can use</font></strike> <strong><font color='green'>POST
   operation on</font></strong> the <strike><font color='red'>session cookie in combination with sticky session
   routing in</font></strike> <strong><font color='green'>RIP trunk URI.

   The usage of</font></strong> the <strike><font color='red'>load balancers to ensure that subsequent requests for</font></strike> <strong><font color='green'>OAuth2.0 flows enables</font></strong> the <strike><font color='red'>same call go</font></strike> <strong><font color='green'>trunking consumer and
   trunking customer</font></strong> to <strong><font color='green'>be</font></strong> the same <strike><font color='red'>call server.  Alternatively, if</font></strike> <strong><font color='green'>(i.e., a cloud PBX provider
   purchases services from a telco), or different (i.e., an enterprise
   customer has purchased trunking services from a telco, and wishes to
   provision them into a cloud contact center that acts as</font></strong> the
   <strike><font color='red'>server</font></strike> <strong><font color='green'>trunking
   consumer).  The latter</font></strong> is <strike><font color='red'>not</font></strike> <strong><font color='green'>often referred to informally as "BYOSIP" in
   traditional SIP trunking and is explicitly supported by RIPP</font></strong> using <strike><font color='red'>any kind of HTTP load balancer at all, it</font></strike>
   <strong><font color='green'>OAuth2.0.

   Once provisioned, either domain</font></strong> can <strike><font color='red'>use</font></strike> <strong><font color='green'>establish capabilities for the
   RIPP trunk by posting</font></strong> a <strike><font color='red'>specific hostname in</font></strike> <strong><font color='green'>capabilities declaration to</font></strong> the <strong><font color='green'>RIPP trunk</font></strong>
   URI <strike><font color='red'>to route all requests for this call to
   a specific instance</font></strike> of <strike><font color='red'>the server.  This technique is particularly
   useful for telcos who have not deployed HTTP infrastructure, but do
   have SBCs.  The root</font></strike> <strong><font color='green'>its peer, using a</font></strong> URI <strike><font color='red'>can use</font></strike> <strong><font color='green'>parameter that signals</font></strong> a <strike><font color='red'>domain</font></strike> <strong><font color='green'>capability
   declaration.  The capabilities declaration is a simple document,</font></strong>
   whose <strike><font color='red'>A records identify
   all</font></strike> <strong><font color='green'>syntax is described in Section XX.  It conveys the receive
   capabilities</font></strong> of the <strike><font color='red'>perimeter SBCs.  Once</font></strike> <strong><font color='green'>entity posting it, and includes parameters like
   maximum bitrate for audio.  This process is optional, and each
   parameter has</font></strong> a <strike><font color='red'>call has landed on a particular
   SBC, the call URI</font></strike> <strong><font color='green'>default.  Either side</font></strong> can <strike><font color='red'>indicate</font></strike> <strong><font color='green'>update its capabilities for</font></strong>
   the <strike><font color='red'>specific hostname</font></strike> <strong><font color='green'>RIPP trunk at any time.  Capability declarations occur outside</font></strong> of <strike><font color='red'>the SBC.

   For example, the root URI for such</font></strike>
   a <strike><font color='red'>telco operator might be:

   &lt;https://sbc-farm.telco.com/calls&gt;</font></strike> <strong><font color='green'>call, are optional,</font></strong> and <strike><font color='red'>the call URIs could be</font></strike> <strong><font color='green'>convey static receive capabilities which
   are a fixed property</font></strong> of the <strike><font color='red'>form:

   &lt;https://sbc-host-{instance-number}.sbc-farm.telco.com/calls/
   id/{UUID&gt;}

   However, the HTTP URI for</font></strike> <strong><font color='green'>RIPP trunk.  Consequently, capability
   declaration is significantly different from SDP offer/answer.

   Either</font></strong> the <strike><font color='red'>call MUST NOT contain an IP address; it
   MUST utilize a valid host</font></strike> <strong><font color='green'>trunking consumer</font></strong> or <strike><font color='red'>domain name.  This is</font></strike> <strong><font color='green'>provider can initiate calls by
   posting</font></strong> to <strike><font color='red'>ensure that TLS
   certificate validation functions properly without manual
   configuration of certificates (a practice which is required still for
   SIP based peering).

   Neither the request, nor</font></strike> the <strike><font color='red'>response, contain bodies.

   FFS: Inclusion</font></strike> <strong><font color='green'>RIPP trunk URI</font></strong> of <strike><font color='red'>bodies</font></strike> <strong><font color='green'>its peer, using a URI parameter that
   signals a new call.  The request contains the target phone number</font></strong> in <strike><font color='red'>requests and responses for signaling
   capabilities?

6.3.  Establishing</font></strike>
   the <strike><font color='red'>Signaling</font></strike> <strong><font color='green'>request URI</font></strong> and <strike><font color='red'>Media Transactions

   To perform signaling</font></strike> <strong><font color='green'>an Identity header field in the HTTP Request.
   The Identity header field is identical in syntax</font></strong> and <strong><font color='green'>semantics</font></strong> to <strike><font color='red'>exchange media for this call, once the
   client has</font></strike> the <strike><font color='red'>call URI, it simultaneously creates a set</font></strike>
   <strong><font color='green'>SIP Identity header field defined in [RFC8224], just carried in HTTP
   instead</font></strong> of <strike><font color='red'>new</font></strike> <strong><font color='green'>SIP.  This</font></strong> request <strike><font color='red'>transactions towards the</font></strike> <strong><font color='green'>returns a globally unique</font></strong> call <strike><font color='red'>URI.  These are called
   signaling transactions and media transactions respectively.

   Both the media and signaling transactions are long running.  This
   means that the client initiates</font></strike> <strong><font color='green'>URI in</font></strong>
   the <strike><font color='red'>connections, sends</font></strike> <strong><font color='green'>Location header field of a 201 response sent by</font></strong> the <strike><font color='red'>headers,
   and then sends</font></strike> <strong><font color='green'>server.
   Typically</font></strong> the <strike><font color='red'>body as</font></strike> <strong><font color='green'>response will also include</font></strong> a <strike><font color='red'>long-running stream (e.g., streaming
   requests).  ((TODO: must confirm that this works with http3 servers -
   it seems ok according</font></strike> <strong><font color='green'>session cookie, bound</font></strong> to
   the <strike><font color='red'>specs though)).  Similarly, the server
   receives the request,</font></strike> <strong><font color='green'>call, to facilitate sticky session routing in HTTP proxies.  This
   allows all further signalling</font></strong> and <strike><font color='red'>if it accepts</font></strike> <strong><font color='green'>media to reach the same RIPP server
   that handled</font></strong> the <strong><font color='green'>initial</font></strong> request, <strike><font color='red'>immediately
   generates</font></strike> <strong><font color='green'>while facilitating failover should
   that server go down.

   Once</font></strong> a <strike><font color='red'>200 response and begins streaming the response body back
   towards the client.  This</font></strike> <strong><font color='green'>call</font></strong> has <strong><font color='green'>been created, a long-lived HTTP transaction is
   initiated from</font></strong> the <strike><font color='red'>property</font></strike> <strong><font color='green'>client to the server for purposes</font></strong> of <strike><font color='red'>creating a</font></strike> <strong><font color='green'>signalling.
   This transaction enables</font></strong> bidirectional data <strike><font color='red'>stream between</font></strike> <strong><font color='green'>flow, tunneled within</font></strong> the <strike><font color='red'>client,</font></strike>
   <strong><font color='green'>body of a long-running HTTP request</font></strong> and <strike><font color='red'>the server.  RIPP
   specific information is carried in that</font></strike> <strong><font color='green'>its long-running response.
   This</font></strong> data <strike><font color='red'>stream.

   The client SHOULD open</font></strike> <strong><font color='green'>flow is called</font></strong> a <strike><font color='red'>single signaling transaction, and SHOULD
   open at least 10 ((FFS: what</font></strike> <strong><font color='green'>byway.  Each byway has a purpose.  One
   byway</font></strong> is <strong><font color='green'>established by</font></strong> the <strike><font color='red'>right number</font></strike> <strong><font color='green'>client for signalling,</font></strong> and <strike><font color='red'>how to negotiate
   proper ranges of values)) media transactions.  The use of</font></strike> multiple
   <strike><font color='red'>media transactions is essential to low latency operation</font></strike>
   <strong><font color='green'>byways for media.  HTTP3 ensures zero RTT for setup</font></strong> of <strike><font color='red'>RIPP.
   This is because, as describe below, media packets are sprayed across</font></strike> these <strike><font color='red'>transactions</font></strike> <strong><font color='green'>byways.

   Signaling commands are encoded into the signalling byway using
   streaming JSON</font></strong> in <strike><font color='red'>order to ensure that there is never head-of-
   line blocking.  This is possible because,</font></strike> <strong><font color='green'>both directions.  Each JSON object encodes an event
   and its parameters.  Events are defined for alerting, connected,
   ended, migrate, keepalive, and transfer-and-takeback.

   The media byways carry a simple binary encoding</font></strong> in <strike><font color='red'>HTTP3, each transaction
   is carried over</font></strike> <strong><font color='green'>both directions.
   Even though data can flow in both directions,</font></strong> a <strike><font color='red'>separate QUIC stream, and QUIC streams run ontop of
   UDP.  ((FFS:</font></strike> <strong><font color='green'>media byway</font></strong> is <strike><font color='red'>there some configuration required</font></strike>
   <strong><font color='green'>unidirectional in terms of media transmission.  A forward media byway
   carries media from the client</font></strong> to <strike><font color='red'>make sure that
   QUIC dosnt multiplex data</font></strike> <strong><font color='green'>the server, and a reverse byway
   carries media</font></strong> from <strike><font color='red'>different streams into</font></strike> the <strike><font color='red'>same UDP
   packet?? This wont cause</font></strike> <strong><font color='green'>server to the client.  To eliminate</font></strong> HOL
   blocking <strike><font color='red'>but will cause amplification of</font></strike> <strong><font color='green'>for media, a media</font></strong> packet <strike><font color='red'>loss))

   The state of the connection</font></strike> is <strike><font color='red'>separate from</font></strike> <strong><font color='green'>sent on a media byway when it
   is first established.  After</font></strong> the <strike><font color='red'>state of</font></strike> <strong><font color='green'>first packet,</font></strong> the <strike><font color='red'>call.
   The</font></strike> client <strike><font color='red'>MAY terminate</font></strike> <strong><font color='green'>cannot be
   sure a subsequent packet will be delayed due to</font></strong> the <strike><font color='red'>connection at any time, and re-establish
   it.  Similarly,</font></strike> <strong><font color='green'>ordering
   guarantees provided by HTTP3 within a stream.  To combat this, both
   sides acknowledge</font></strong> the <strike><font color='red'>server or cient may end</font></strike> <strong><font color='green'>receipt of each packet using an ACK message
   sent over</font></strong> the <strike><font color='red'>signaling or</font></strike> media
   <strike><font color='red'>transactions, and restart them too.  RIPP provides identifiers and
   sequencing at the application layer</font></strike> <strong><font color='green'>byways,</font></strong> in <strike><font color='red'>order to facilitate this
   process.  This process is an essential part</font></strike> <strong><font color='green'>the opposite direction</font></strong> of <strike><font color='red'>this specification,
   due to</font></strike> the <strike><font color='red'>high likelihood that streams, connections, and servers
   fail at some point during</font></strike> <strong><font color='green'>media.
   Consequently, in</font></strong> a <strike><font color='red'>call.  This is described</font></strike> <strong><font color='green'>forward media byway, ACK messages are carried from
   server to client, and</font></strong> in <strike><font color='red'>more detail
   below.

   To initiate</font></strike> a <strike><font color='red'>signaling transaction, the</font></strike> <strong><font color='green'>reverse media byway, they are carried from</font></strong>
   client <strike><font color='red'>MUST initiate a POST
   request</font></strike> to <strike><font color='red'>the call URI, and MUST include the signaling URI
   parameter.  To initiate</font></strike> <strong><font color='green'>server.  Once</font></strong> a media <strike><font color='red'>transaction, it MUST include</font></strike> <strong><font color='green'>packet is acknowledged,</font></strong> the media <strike><font color='red'>URI parameter.  These requests MUST NOT include the newcall URI
   parameter.  A client MUST NOT include both the</font></strike>
   <strong><font color='green'>byway can be used once again without fear of HOL blocking.  Because
   each</font></strong> media <strike><font color='red'>and signaling
   parameters in a request.  This</font></strike> <strong><font color='green'>packet</font></strong> is <strike><font color='red'>because media</font></strike> <strong><font color='green'>acknowledged independently, each side can
   compute statistics on packet losses</font></strong> and <strike><font color='red'>signaling utilize
   different framing within</font></strike> <strong><font color='green'>delays.  Consequently,</font></strong> the <strike><font color='red'>data stream</font></strike>
   <strong><font color='green'>equivalent of RTCP sender</font></strong> and <strike><font color='red'>cannot be multiplexed.

   The requests to create these transactions MUST include headers</font></strike> <strong><font color='green'>receiver reports are not needed.

   RIPP defines some basic requirements</font></strong> for
   <strike><font color='red'>any applicable session cookies.

   When opening a media transaction,</font></strike> <strong><font color='green'>congestion control at</font></strong> the
   client <strike><font color='red'>MUST include a RIPP-
   Media header field</font></strike> <strong><font color='green'>side.  Specifically, clients drop media packets if there are
   too many media byways</font></strong> in the <strike><font color='red'>request headers.  Simiarly, the</font></strike> <strong><font color='green'>blocked state.

   RIPP provides a simple technique for allowing a call to seamlessly
   migrate from one client instance to another on a different host, or
   from one</font></strong> server <strike><font color='red'>MUST
   include this header in the response headers.  This header contains</font></strike> <strong><font color='green'>instance to another on</font></strong> a
   <strike><font color='red'>channel number, the name of</font></strike> <strong><font color='green'>different host.  For a
   client, it need only end</font></strong> the <strike><font color='red'>codec used</font></strike> <strong><font color='green'>byways</font></strong> in <strong><font color='green'>use for</font></strong> the <strike><font color='red'>stream,</font></strike> <strong><font color='green'>call</font></strong> and <strong><font color='green'>re-
   initiate from</font></strong> a
   <strike><font color='red'>timestamp conveying</font></strike> <strong><font color='green'>different instance.  Similarly, a server can request
   migration, and this triggers</font></strong> the <strike><font color='red'>wall clock time corresponding</font></strike> <strong><font color='green'>client</font></strong> to <strong><font color='green'>perform this same action.
   The call state persists independently of</font></strong> the <strike><font color='red'>time at
   which</font></strike> <strong><font color='green'>state of</font></strong> the <strike><font color='red'>media packets</font></strike> <strong><font color='green'>HTTP
   connection or the byways embedded</font></strong> in <strong><font color='green'>HTTP transactions, so</font></strong> that <strike><font color='red'>stream were received or generated</font></strike> <strong><font color='green'>a
   reconnect can continue where things left off.

   Finally, RIPP trunks can be destroyed by a trunking consumer</font></strong> by
   <strong><font color='green'>issuing a DELETE against</font></strong> the <strike><font color='red'>client.  The timestamp also includes timestamps received</font></strike> <strong><font color='green'>RIPP trunk URI.

7.  Example

   This section describes a typical example where one company, Acme, is
   using a cloud call service, Webex, and gets PSTN trying</font></strong> from <strike><font color='red'>any
   upstream servers, providing an e2e timing trace for</font></strike> the <strike><font color='red'>media path.
   ((TODO: need</font></strike>
   <strong><font color='green'>provider Comcast.

   The first stage is the Webex set up their service</font></strong> to <strike><font color='red'>fill in details)).

   RIPP supports multiple channels, meant for handling stereo audio.
   Each channel MUST</font></strike> be <strike><font color='red'>its own media transaction.  Channel number zero
   is reserved for</font></strike> <strong><font color='green'>able to work
   as an OAuth Resource Server working with ComCast as</font></strong> the <strike><font color='red'>media command channel.</font></strike> <strong><font color='green'>Authorization
   Server and understand the baseURI that ComCast uses for RIPP.  Assume
   that this is "https://ripp.comcast.com".</font></strong>  The <strike><font color='red'>media command channel
   - unlike</font></strike> <strong><font color='green'>next stage is</font></strong> the <strike><font color='red'>media channels - requires reliability, and thus media
   frames</font></strike> <strong><font color='green'>admin
   from ACME logs</font></strong> on <strike><font color='red'>this channel are never acknowledged.  Indeed,</font></strike> the <strike><font color='red'>primary
   purpose of</font></strike> <strong><font color='green'>Webex account and selects Comcast as</font></strong> the <strike><font color='red'>media command channel is</font></strike> <strong><font color='green'>RIPP
   provider.  This will cause the OAUTH dance and the admin will end up
   having approved WebEX</font></strong> to <strike><font color='red'>convey acknowledgements
   for media packets.  The client MUST open</font></strike> <strong><font color='green'>use Acme's account</font></strong> at <strike><font color='red'>least one media
   transaction on channel 0.

   ((FFS: any other headers we need to talk about??))

6.4.  Terminating and Re-establishing Media and Signaling Transactions

   The originating domain MUST ensure that there is always at least one
   signaling connection,</font></strike> <strong><font color='green'>ComCast for RIPP.
   Webex will have received an OAuth access</font></strong> and <strike><font color='red'>at least 10 media conncetions between the
   originating domain</font></strike> <strong><font color='green'>refresh token from
   ComCast</font></strong> and <strong><font color='green'>be redirected to</font></strong> the <strike><font color='red'>call URI, for a specific call.  As such,
   if a transaction ends or</font></strike> <strong><font color='green'>new Provider Trunk URI.  At this
   point,</font></strong> the <strike><font color='red'>connection breaks or</font></strike> <strong><font color='green'>pre setup</font></strong> is <strike><font color='red'>migrated,</font></strike> <strong><font color='green'>read and RIPP can start.  Assume</font></strong> the
   <strike><font color='red'>client MUST re-initiate these transactions immediately, or risk loss</font></strike> <strong><font color='green'>base
   provider trunk returned is "https://ripp.comcast.com/trunks/
   wbx234acme".

   Webex will start by setting up for incoming calls at
   "https://ripp.webex/trunks/acme123" with an opaque security token</font></strong> of <strike><font color='red'>media and signaling events.  However,</font></strike>
   <strong><font color='green'>"secret1234".  This is done by making a HTTP PUT</font></strong> to <strike><font color='red'>deal</font></strike>
   <strong><font color='green'>https://ripp.comcast.com/trunks/wbx234acme/consumerTrunk</font></strong> with <strike><font color='red'>the fact that
   re-establishment takes time, both client and</font></strike> <strong><font color='green'>a JSON
   body of:

         {
         "consumerTrunkURI":"https://ripp.webex/trunks/acme123 " ,
         "consumerToken":"secret1234"
         }

   The ComCast</font></strong> server <strike><font color='red'>MUST buffer their
   signaling and media streams for at least 5 seconds, and</font></strike> <strong><font color='green'>will</font></strong> then <strike><font color='red'>once</font></strike> <strong><font color='green'>validate</font></strong> the
   <strike><font color='red'>connections</font></strike> <strong><font color='green'>token</font></strong> and <strike><font color='red'>streams</font></strike> <strong><font color='green'>URI</font></strong> are <strike><font color='red'>re-established, it sends all buffered
   data immediately.

   Note that it is</font></strike> <strong><font color='green'>correct
   as well as find out</font></strong> the <strike><font color='red'>sole responsibility</font></strike> <strong><font color='green'>advertised capability</font></strong> of the <strike><font color='red'>client</font></strike> <strong><font color='green'>Webex trunk by
   doing a GET</font></strong> to <strike><font color='red'>make sure
   these connections are re-established if they fail unexpectedly.

   These rules result in the creation of at least one bidirectional byte
   stream between originating</font></strike> <strong><font color='green'>https://ripp.webex/trunks/acme123/capAdv</font></strong> and <strike><font color='red'>terminating server</font></strike> <strong><font color='green'>using the
   secret1234 as an authorization token.  Webex supports the default
   values but also support G.729 as an additional codec so it needs</font></strong> to <strike><font color='red'>be used</font></strike>
   <strong><font color='green'>return the list of codecs supported.  It returns a JSON body of:

          { "codec":  [ "opus", "g711", "dtmf", "cn", "g729" ] }

   At this point we are ready</font></strong> for
   <strike><font color='red'>signaling, and</font></strike> <strong><font color='green'>inbound or outbound calls.

7.1.  Inbound Call

   A PSTN calls arrives</font></strong> at <strike><font color='red'>least ten bidirectional byte streams for media.

6.5.  Media Negotiation

   There</font></strike> <strong><font color='green'>Comcast that</font></strong> is <strike><font color='red'>no offer-answer model.  Only two codecs are supported - G711
   and Opus.  All entities must support both.  Without</font></strike> <strong><font color='green'>routed to</font></strong> the <strike><font color='red'>need</font></strike> <strong><font color='green'>this trunk via
   a Comcast SBC that will convert it from SIP</font></strong> to
   <strike><font color='red'>signal media destinations - IP and ports - there is no longer a need
   for SDP.  Either side can modify</font></strike> <strong><font color='green'>RIPP.  The SBC knows
   which</font></strong> codecs <strike><font color='red'>at will, without signaling.
   They can also adjust frame sizes within a range defined by this
   specification.  There is no SRTP, as described above.

   Future extensions will consider</font></strike> the <strike><font color='red'>addition of a declarative model,
   where each side</font></strike> <strong><font color='green'>trunk the support and</font></strong> can <strong><font color='green'>immediately</font></strong> send <strike><font color='red'>settings which are then cached and span
   across multiple calls, in much</font></strike> the <strike><font color='red'>same way it works with HTTP/3
   itself.

6.6.  Framing

   Both signaling and media are carried over</font></strike> <strong><font color='green'>SIP
   answer in</font></strong> a <strike><font color='red'>bidirectional byte stream
   that is established by</font></strike> <strong><font color='green'>183 then can make HTTP post to</font></strong> the <strike><font color='red'>client.  Signaling uses self-delineating
   text frames.</font></strike> <strong><font color='green'>consumer trunk URI to
   set up the incoming call.</font></strong>  This is <strike><font color='red'>done to enable end users</font></strike> <strong><font color='green'>does by doing a POST</font></strong> to <strike><font color='red'>initiate signaling
   easily from command line applications like curl, and through
   interactive developer portals.  Media is sent</font></strike>
   <strong><font color='green'>"https://ripp.webex/trunks/acme123/calls"</font></strong> using <strong><font color='green'>the authorization
   token "secret1234".  This will return</font></strong> a <strike><font color='red'>simple binary
   framing, similar</font></strike> <strong><font color='green'>new call URI for this call of
   https://ripp.webex/call/c567.

   At this point the SBC can make a long poll GET</font></strong> to <strike><font color='red'>- but not identical</font></strike>
   <strong><font color='green'>"https://ripp.webex/call/c567/events"</font></strong> to <strike><font color='red'>- RTP.

6.6.1.  Signaling Framing

   Signaling is carried as</font></strike> <strong><font color='green'>get any update events about
   this call.  The SBC will also open</font></strong> a <strike><font color='red'>series</font></strike> <strong><font color='green'>number</font></strong> of <strike><font color='red'>valid JSON objects.  If there is
   more than one object</font></strike> <strong><font color='green'>byways by making POST
   requests to "https://ripp.webex/call/c567/media-up" and
   "https://ripp.webex/call/c567/media-down"</font></strong> to <strong><font color='green'>send and receive media.

   For each of the media-up byways, the Comcast SBC will send
   BywayPreamble that tells the other side meta data about what will</font></strong> be
   sent <strike><font color='red'>over a transaction, the JSON objects
   are separated by a visual separator consistenting of ten contiguous
   instances of</font></strike> <strong><font color='green'>on this byway.  For</font></strong> the <strike><font color='red'>ascii dash "-", followed by a CRLF.  As a result,</font></strike> <strong><font color='green'>media-down byways,</font></strong> the <strike><font color='red'>JSON itself MUST NOT ever contain more than ten dashes in a row.
   Since</font></strike> <strong><font color='green'>Webex server will
   sen</font></strong> the <strike><font color='red'>JSON is extensible, future extensions MUST NOT ever specify
   new fields which contain 10 or more dashes.</font></strike> <strong><font color='green'>BywayPreamble.</font></strong>  The <strike><font color='red'>usage of</font></strike> <strong><font color='green'>BywayPreamble contains</font></strong> the <strike><font color='red'>dashes allows</font></strike> <strong><font color='green'>name of</font></strong> the <strike><font color='red'>receiving client to extract
   independent objects from</font></strike>
   <strong><font color='green'>codec,</font></strong> the <strike><font color='red'>stream without performing JSON parsing
   or validation.  ((TODO: should we limit the size of an individual
   JSON object?))

   HTTP compression is used to reduce the on-the-wire penalty for using
   JSON.  Since this is transparent, it enables an easy developer
   interface to RIPP without the penalty of text encoding.  ((TODO:
   specify more details on how</font></strike> <strong><font color='green'>base sequence number, frameTime, and baseTime.  After</font></strong> this <strike><font color='red'>works - assumes</font></strike>
   <strong><font color='green'>BywayPreamble, media frames can be sent</font></strong> that <strike><font color='red'>HTTP does in
   fact do payload compression vs. requiring the application to do
   it??))

6.6.2.  Media Framing

   Media is carried as a series of binary objects.  These binary objects</font></strike> contain a <strike><font color='red'>7 bit payload type value (mirroring RTP), a 32 bit</font></strike> <strong><font color='green'>seqOffset
   number, media length, and then the media data.  The receiver compute
   the time</font></strong> sequence number <strike><font color='red'>(twice as large as RTP), and a single bit</font></strike> for <strike><font color='red'>reserved.  This
   is followed</font></strike> <strong><font color='green'>the frame</font></strong> by <strike><font color='red'>a variable length length field that describes</font></strike> <strong><font color='green'>adding</font></strong> the
   <strike><font color='red'>length of</font></strike> <strong><font color='green'>baseSeqNum for</font></strong>
   the <strike><font color='red'>data which follows, in bytes.  The data which follows
   is</font></strike> <strong><font color='green'>byway to the seqOffset for</font></strong> the <strike><font color='red'>codec</font></strike> frame.  The <strike><font color='red'>minimum length</font></strike> <strong><font color='green'>timestamp</font></strong> for the <strike><font color='red'>length field</font></strike>
   <strong><font color='green'>media</font></strong> is <strike><font color='red'>8
   bits.  This means</font></strike> <strong><font color='green'>computed using</font></strong> the <strike><font color='red'>framing has a minimum size of 6 bytes,
   significantly smaller than</font></strike> <strong><font color='green'>baseTime for</font></strong> the <strike><font color='red'>RTP minimum</font></strike> <strong><font color='green'>byway plus the packeTime
   multiplied by the seqNum.

   The data from the https://ripp.webex/call/c567/events request will be
   an infinite JSON array</font></strong> of <strike><font color='red'>12 bytes.
   Consequently, RIPP</font></strike> <strong><font color='green'>Events.  When the Webex server answers the
   call, the event returned would look like:

                           { "name":"accepted" }

7.2.  Outbound Call

   For Webex to make it outbound call, it</font></strong> is <strike><font color='red'>more bandwidth efficient</font></strike> <strong><font color='green'>the same as the inbound
   call other</font></strong> than <strike><font color='red'>RTP when used
   with long running transactions.

   Because there is no separate timestamp, RIPP does not permit</font></strike> the <strike><font color='red'>use
   of non-exitent frames to convey silence.</font></strike> <strong><font color='green'>provider trunk URI is used.</font></strong>  The <strike><font color='red'>encoder used by the
   client MUST emit</font></strike> <strong><font color='green'>Webex server
   would act as</font></strong> a <strike><font color='red'>contiuous series of frames based on its sending
   clock.  If there is</font></strike> <strong><font color='green'>client and do</font></strong> a <strike><font color='red'>desire</font></strike> <strong><font color='green'>HTTP POST</font></strong> to <strike><font color='red'>use lower bandwidth during silence
   periods, the encode must transcode</font></strike>
   <strong><font color='green'>"https://ripp.comcast.com/trunks/wbx234acme/calls"</font></strong> to <strike><font color='red'>Opus (which</font></strike> <strong><font color='green'>create a call
   URI of "http\s://ripp.comcast.com/call/c789".  From that point the
   flow</font></strong> is <strike><font color='red'>more efficient
   during silence periods), or else fill in</font></strike> <strong><font color='green'>roughly</font></strong> the <strike><font color='red'>time gap</font></strike> <strong><font color='green'>same as inbound</font></strong> with <strike><font color='red'>comfort
   noise using RFC3389, whose support is required by this specification.
   See details below on usage of RFC3389 with RIPP.

   The sequence number space is unique for each direction, and unique
   for each call (as identified by the call URI).  Each side MUST start</font></strike> the <strike><font color='red'>sequence number at zero,</font></strike> <strong><font color='green'>client</font></strong> and <strike><font color='red'>MUST inccrement it by one for each
   subsequent media frame.  With 32 bits of sequence space, starting at
   zero, with a minimum frame size</font></strike> <strong><font color='green'>server roles
   reversed.

7.3.  End</font></strong> of <strike><font color='red'>10ms, RIPP can support</font></strike> call
   <strike><font color='red'>durations as long as 11,930 hours.  Rollover of</font></strike>

   <strong><font color='green'>If</font></strong> the <strike><font color='red'>sequence number</font></strike> <strong><font color='green'>call</font></strong> is <strike><font color='red'>not permitted,</font></strike> <strong><font color='green'>ended on</font></strong> the <strike><font color='red'>client or</font></strike> server <strike><font color='red'>MUST end the call before
   rollover.  This means that the combination of call URI, direction
   (client to server, or</font></strike> <strong><font color='green'>side,</font></strong> server <strong><font color='green'>sends a terminated
   event with the ended flag set</font></strong> to <strike><font color='red'>client), channel number, and sequence
   number represent</font></strike> <strong><font color='green'>true then waits</font></strong> a <strike><font color='red'>unique identifier in space and</font></strike> <strong><font color='green'>small</font></strong> time for <strike><font color='red'>media
   packets.

6.7.  Signaling - Events

   Signaling is performed by having the</font></strike>
   client <strike><font color='red'>and server exchange
   events.  Each event is a JSON object embedded in</font></strike> <strong><font color='green'>to close</font></strong> the <strike><font color='red'>signaling
   stream, which conveys</font></strike> <strong><font color='green'>connection then closes</font></strong> the <strike><font color='red'>event as perceived by</font></strike> <strong><font color='green'>connection.

   If</font></strong> the <strike><font color='red'>client or server.
   Each event has a sequence number, which starts at zero for a call,
   and increases by one for each event.  The sequence number space</font></strike> <strong><font color='green'>call</font></strong> is
   <strike><font color='red'>unique in each direction.  The event also contains a direction field,
   which indicates whether</font></strike> <strong><font color='green'>ended on</font></strong> the <strike><font color='red'>event was sent from</font></strike> client <strike><font color='red'>to server, or
   server to client.  It also contains</font></strike> <strong><font color='green'>side, the client sends</font></strong> a <strike><font color='red'>timestamp field, which
   indicates</font></strike>
   <strong><font color='green'>terminated event with</font></strong> the <strike><font color='red'>time of</font></strike> <strong><font color='green'>ended flag set to true and then closes</font></strong> the <strike><font color='red'>event as perceived by</font></strike>
   <strong><font color='green'>connection.  In either case</font></strong> the <strike><font color='red'>sender.</font></strike> <strong><font color='green'>even looks like:

                  { "name":"terminated", "ended": true }

8.  Detailed Behaviours</font></strong>

   This
   <strike><font color='red'>timestamp is not updated when retransmissions happen; the timestamp
   exists at</font></strike> <strong><font color='green'>section provides an overview of</font></strong> the <strong><font color='green'>operation of RIPP.

8.1.  Configuration</font></strong>

   RIPP <strike><font color='red'>application layer and</font></strike> <strong><font color='green'>configuration happens when a trunking consumer wishes to be able
   to provision, on demand, new</font></strong> RIPP <strike><font color='red'>cannot directly observe
   HTTP retransmits.

   It also contains</font></strike> <strong><font color='green'>trunks with</font></strong> a <strike><font color='red'>call field, which contains the URI of the call in
   question.

   Finally, there</font></strike> <strong><font color='green'>trunking provider.

   One example use case</font></strong> is <strong><font color='green'>that of</font></strong> an <strike><font color='red'>event type field,</font></strike> <strong><font color='green'>enterprise,</font></strong> which <strike><font color='red'>conveys the type</font></strike> <strong><font color='green'>has deployed an
   IP PBX</font></strong> of
   <strike><font color='red'>event.  This is followed by additional fields which are specific</font></strike> <strong><font color='green'>some sort within its data centers.  Once deployed, the
   enterprise needs</font></strong> to <strong><font color='green'>enable</font></strong> the <strike><font color='red'>event type.

   This structure means that each event carried in</font></strike> <strong><font color='green'>PBX to place and receive calls towards</font></strong>
   the <strike><font color='red'>signaling is
   totally self-describing, irregardless</font></strike> <strong><font color='green'>PSTN.  The enterprise contracts with a RIPP trunking provider.
   All of this happens as a precursor to configuration.  At the end</font></strong> of
   the <strike><font color='red'>enclosing connection</font></strike> <strong><font color='green'>contracting process, the enterprise administrator will visit the
   configuration web page,</font></strong> and
   <strike><font color='red'>stream.</font></strike> <strong><font color='green'>be able to register their enterprise PBX.</font></strong>
   This <strike><font color='red'>greatly facilitates logging, debugging,
   retransmissions, retries,</font></strike> <strong><font color='green'>process will typically return a client-ID, client-secret,</font></strong> and <strike><font color='red'>other race conditions which may deliver</font></strike>
   <strong><font color='green'>authorization endpoint URL.  The administrator manually enters these
   into</font></strong> the <strike><font color='red'>same event multiple times, or deliver an event to</font></strike> <strong><font color='green'>configuration of their PBX.  [[OPEN ISSUE: OpenID connect?]]

   As another example use case,</font></strong> a <strike><font color='red'>server</font></strike> <strong><font color='green'>cloud contact center, cloud PBX
   provider, or any other saas application</font></strong> which
   <strike><font color='red'>is not aware of the call.

   This specification defines the following events:

   start: Passed from client</font></strike> <strong><font color='green'>wishes</font></strong> to <strike><font color='red'>server, it tells the server</font></strike> <strong><font color='green'>obtain
   trunking services, can contract with a RIPP trunking provider.  In a
   similar process</font></strong> to <strike><font color='red'>begin
   processing of the specific call.  This event is</font></strike> the <strike><font color='red'>first event
   delivered to</font></strike> <strong><font color='green'>enterprise case above,</font></strong> the <strike><font color='red'>call URI by</font></strike> <strong><font color='green'>administrator
   obtains a clientID, client-secret, and authorization endpoint URL
   which are configured into their service.

   In</font></strong> the <strike><font color='red'>client.

   started: Passed</font></strike> <strong><font color='green'>final use case, an enterprise administrator has purchased
   trunking services</font></strong> from <strike><font color='red'>server to</font></strike> <strong><font color='green'>a RIPP trunking provider.  They separately
   have purchased cloud PBX, cloud contact center, or another saas
   service which requires connectivity to a RIPP trunk.  In this case,
   the cloud PBX, cloud contact center, or other saas service acts as
   the RIPP trunk consumer.  The RIPP trunk consumer would configure
   itself as a client with a variety of RIPP trunking providers, and for
   each, obtain the clientID, client-secret and authorization URL.  This
   will allow the customers of the RIPP trunking consumer to provision
   RIPP trunks automatically, and point them to the RIPP trunking
   consumer.

8.2.  RIPP Trunk Provisioning

   Once a RIPP consumer has been configured as an OAuth client
   application with a RIPP provider, a RIPP customer can provision a
   RIPP trunk on-demand using a web form.  RIPP consumers will typically
   provide a self-service web form for such provisioning, since self-
   service and instant provisioning are key goals of RIPP.

   The RIPP customer visits this web form, and selects their provider.
   The RIPP consumer would then initiate an OAuth2.0 authorization code
   flow.  This utilizes the clientID, client-secret and authorization
   endpoint URL configured previously.  The RIPP customer will
   authenticate to the RIPP provider, and authorize creation of a new
   RIPP trunk.

   Once the RIPP customer authorizes creation of a RIPP trunk, the RIPP
   provider MUST generate an authorization code and follow the
   procedures defined in [RFC6749] for the authorization code grant
   flow.  Furthermore, the RIPP provider MUST mint a new URI identifying
   this new RIPP trunk.  This URI MUST contain a path component, and
   MUST NOT contain any URI parameters.  This URI MUST be an HTTPS URI,
   and HTTP3 MUST be supported for this URI.  The path component MUST be
   a globally unique identifier for this trunk, and not depend on the
   authority component as part of the namespace for purposes of
   uniqueness.

   As an example, the following is a valid RIPP trunk URI:

   &lt;https://ripp.telco.com/trunks/6ha937fjjj9&gt;

   This URI MUST be returned in the OAuth2.0 parameter "ripp-trunk", and
   MUST be base64 encoded.

   The RIPP consumer MUST follow the procedures defined in [RFC6749] for
   an OAuth</font></strong> client, <strike><font color='red'>confirming</font></strike> <strong><font color='green'>trade in its authorization code for both a refresh
   and access token.  The RIPP provider MUST issue both refresh and
   access tokens.  It is expected that the refresh token will last a
   long time, in order to avoid the resource owner needing to manually
   re-authorize.  The trunk consumer MUST be prepared for its access and
   refresh tokens to be invalidated at any time.  The RIPP consumer MUST
   extract the "ripp-trunk" OAuth parameter from the authorization
   response, decode, and persist it.

   Once the RIPP consumer has obtained an access token, it MUST initiate
   an HTTPS POST request towards the RIPP trunk URI.  This request MUST
   include the "ripp-provision" URI parameter.  This request MUST
   contain an Authorization header field utilizing the access token just
   obtained.  It MUST include a RIPP provisioning object in the body.
   This object is specified in Section XX.

   The RIPP provisioning object MUST contain a RIPP Trunk Client URI and
   a RIPP bearer token.  The RIPP consumer MUST mint an HTTPS URI for
   the RIPP Trunk Client URI.  This URI MUST support HTTP3, and MUST
   implement the behaviours associated with capabilities and new call
   operations as defined below.  This URI MUST have a path component,
   MUST NOT contain any URI parameters, and MUST have a path segment
   which is globally unique.

   In addition, the RIPP consumer MUST mint a bearer token to be used by
   the RIPP provider when performing operations against the RIPP Trunk
   Client URI.  The bearer token MAY be constructed in any way desired
   by the RIPP consumer.  The token and URI MUST remain valid for at
   least one day.  The RIPP consumer MUST refresh the provisioning
   against the RIPP trunk at least one hour in advance of the
   expiration, in order to ensure no calls are delayed.

   At this point, the RIPP trunk is provisioned.  Both the RIPP provider
   and RIPP consumer have a RIPP trunk URI and an Authorization token to
   be used for placing calls in each direction.

8.3.  Capabilities

   Once provisioned, either the consumer or provider sets capabilities
   for the trunk.  If either side wishes to declare capabilities that
   are not default, it MUST establish capabilities immediately upon
   trunk creation.  To do that, the client performs an HTTP POST to its
   peer's RIPP trunk URI.  It MUST include the URI parameter "ripp-
   caps".  The body MUST be a RIPP capabilities object as defined in
   Section XX.

   Once established, either side MAY update the capabilities with a
   fresh POST request.  Due to race conditions, it is possible that the
   client may receive calls compliant to the old capabilities document
   for a brief interval.  It MUST be prepared for this.

   When the trunk resource is destroyed, its associated capabilities are
   also destroyed.

   The RIPP capabilities document is a list of name-value pairs, which
   specify a capability.  Every capability has a default, so that if no
   document is posted, or it is posted but a specific capability is not
   included, the capability for the peer is understood.  Capabilities
   are receive only, and specify what the entity is willing to receive.

   Capabilities MAY be changed at any time by posting a new capability
   document.  Capabilities are bound to the RIPP trunk, and are
   destroyed when the RIPP trunk is destroyed.

   This specification defines the following capability set.  This set is
   extensible through an IANA registry.

   o  max-opus-bitrate: The maximum bitrate for receiving Opus voice.
      This is specified in bits per second.  It MUST be greater than or
      equal to

      1.  Its default is 32000.

   o  max-opus-samplerate: The maximum sample rate for Opus audio.  This
      is specified in Hz.  It MUST be greater than or equal to 8000.
      Its default is 8000.

   o  opus-vbr: Indicates whether the entity supports receiving variable
      rate Opus audio.  It MUST be either "true" or "false".  The
      default is "true".  If "false", the sender MUST send constant rate
      audio.

   o  two-channel: Indicates whether the entity supports receiving two
      audio channels or not.  Two channel audio is specifically used for
      RIPP trunks meant to convey listen-only media for the purposes of
      recording, similar to SIPREC [RFC7866].  It MUST be either "true"
      or "false".  The default is "false".

   o  tnt: Indicates whether the entity supports the takeback-and-
      transfer command.  Telcos supporting this feature on a trunk would
      set it to "true".  The value MUST be "true" or "false".  The
      default is "false".

   In addition, codecs can be listed as capabilities.  This is done by
   using the media type and subtype, separated by a "/", as the
   capability name.  Media type and subtype values are taken from the
   IANA registry for RTP payload format media types, as defined in
   [RFC4855].  The value of the capability is "true" if the codec is
   supported, "false" if it is not.  The default is "false" for all
   codecs except for "audio/PCMU", "audio/opus", "audio/telephone-event"
   and "audio/CN", for which the default is "true".  Because codec
   capabilities are receive-only, it is possible, and totally
   acceptable, for there to be different audio codecs used in each
   direction.

   In general, an entity MUST declare a capability for any
   characteristic of a call which may result in the call being rejected.
   This requirement facilitates prevention of call failures, along with
   clear indications of why calls have failed when they do.  For
   example, if a RIPP trunk provider provisions a trunk without support
   for G.729, but the consumer configures their to utilize this codec,
   this will be known as a misconfiguration immediately.  This enables
   validation of trunk configurations in an automated fashion, without
   placing test calls or calling customer support.

8.4.  Initiating Calls

   HTTP connections are completely independent of RIPP trunks or calls.
   As such, RIPP clients SHOULD reuse existing HTTP connections for any
   request targeted at the same authority to which an existing HTTP
   connection is open.  RIPP clients SHOULD also utilize 0-RTT HTTP
   procedures in order to speed up call setup times.

   To initiate a new call, a RIPP client creates an HTTPS POST request
   to the RIPP trunk URI of its peer.  For a trunking consumer, this is
   the RIPP trunk URI provisioned during the OAuth2.0 flow.  For the
   trunking provider, it is the RIPP trunk client URI learned through
   the provisioning POST operation.  This MUST be an HTTP/3 transaction.
   The client MUST validate that the TLS certificate that is returned
   matches the authority component of the RIPP trunk URI.

   The client MUST append the RIPP trunk URI with the attribute
   "newcall".  For example:

   &lt;https://ripp.telco.com/trunks/6ha937fjjj9?newcall&gt;

   This request MUST contain the token that the client has obtained out-
   of-band.  For the RIPP trunk consumer, this is the OAuth token.  For
   the RIPP trunk provider, it is the bearer token learned through the
   provisioning POST operation.

   The client MUST also add the "target" URI parameter.  This parameter
   MUST be of the form user@domain.  If the target is a phone number on
   the PSTN, this must take the form @e164.arpa, where is a valid E.164
   number.  RIPP also supports private trunks, in which case the it MUST
   take the form @, where the number is a non-E164 number scoped to be
   valid within the domain.  This form MUST NOT be used for E.164
   numbers.  Finally, RIPP can be used to place call to application
   services - such as a recorder - in which case the parameter would
   take the form of an RFC822 email address.

   The client MUST add an HTTP Identity header field.  This header field
   is defined in Section XX as a new HTTP header field.  Its contents
   MUST be a valid Identity header field as defined by [RFC8224].  This
   ensures that all calls utilize secure caller ID.  A RIPP client MUST
   NOT place the caller ID in any place except for the Identity header
   field in this request.  Specifically, a "From", "Contact", or "P-
   Asserted-ID" header field MUST NOT ever appear.

   The server MUST validate the OAuth token, MUST act as the verifying
   party to verify the Identity header field, and then authorize the
   creation of a new call, and then either accept or reject the request.
   If accepted, it indicates that the server is willing to create this
   call.  The server MUST return a 201 Created response, and MUST
   include a Location header field containing an HTTPS URI which
   identifies the call that has been created.  The URI identifying the
   call MUST include a path segment which contains a type 4 UUID,
   ensuring that call identifiers are globally unique.  This URI MUST
   have a path underneath the RIPP trunk URI, to enable easy mapping of
   calls to trunks.

   An example URI that identifies a call is:

   &lt;https://ripp.telco.com/trunks/6ha937fjjj9/calls/
   ha8d7f6fso29s88clzopa&gt;

   The server MAY include an HTTP session cookie in the 201 response.
   The client MUST support receipt of cookies [RFC6265].  It MUST be
   prepared to receive up to 10 cookies per call.  The client MUST
   destroy all cookies associated with a call, when the call has ended.
   Cookies MUST NOT be larger the 5K.

   The usage of an HTTP URI to identify the call itself, combined with
   session cookies, gives the terminating RIPP domain a great deal of
   flexibility in how it manages state for the call.  In traditional
   softswitch designs, call and media state is held in-memory in the
   server and not placed into databases.  In such a design, a RIPP
   server can use the session cookie in combination with sticky session
   routing in the load balancers to ensure that subsequent requests for
   the same call go to the same call server.  Alternatively, if the
   server is not using any kind of HTTP load balancer at all, it can use
   a specific hostname in the URI to route all requests for this call to
   a specific instance of the server.  This technique is particularly
   useful for telcos who have not deployed HTTP infrastructure, but do
   have SBCs that sit behind a single VIP.  The root URI can use a
   domain whose A record maps to this IP.  Once a call has landed on a
   particular SBC, the call URI can indicate the specific IP of the SBC.

   For example, the RIPP trunk URI for such a telco operator might be:

   &lt;https://sbc-farm.telco.com/trunks/6ha937fjjj9&gt;

   which always resolves to 1.2.3.4, the VIP shared amongst the SBC
   farm.  Consequently, a request to this RIPP trunk would hit a
   specific SBC behind the VIP.  This SBC would then create the call and
   return a call URL which points to its actual IP, using DNS

   &lt;https://sbc23.sbc-farm.telco.com/trunks/6ha937fjjj9/calls/
   ha8d7f6fso29s88clzopa&gt;

   However, the HTTP URI for the call MUST NOT contain an IP address; it
   MUST utilize a valid host or domain name.  This is to ensure that TLS
   certificate validation functions properly without manual
   configuration of certificates (a practice which is required still for
   SIP based peering).

   Neither the request, nor the response, contain bodies.

8.5.  Establishing the Signaling Byway

   To perform signalling for this call, the client MUST initiate an HTTP
   request towards the call URI that it just obtained.

   The signaling is accomplished by a long running HTTP transaction.
   This means that the client initiates the connection, sends the
   headers, and then sends the body as a long-running stream (e.g.,
   streaming requests).  Similarly, the server receives the request, and
   if it accepts the request, immediately generates a 200 response and
   begins streaming the response body back towards the client.  This has
   the property of creating a bidirectional data stream between the
   client, and the server.  This bidirectional stream is an ordered byte
   stream, and is called a byway.  RIPP specific information is carried
   in the byway.

   To initiate a signalling byway, the client MUST initiate a POST
   request to the call URI, and MUST include the URI parameter
   "signalling".  This request MUST NOT include any other URI
   parameters.

   The signalling byway utilizes a streaming JSON format, specified in
   XXX.  This begins with an open curly bracket, and after that is a
   series of JSON objects, each starting with a curly bracket, and
   ending with a curly bracket.  Consequently, each side MUST
   immediately send their respective open brackets after the HTTP header
   fields.  We utilize streaming JSON in order to facilitate usage of
   tools like CURL for signalling operations.

8.6.  The Media Sequence

   In RIPP, media is represented as a continuous sequence of RIPP media
   frames embedded in a media byway.  Each ripp media frame encodes a
   variable length sequence number offset, followed by a variable length
   length field, followed by a codec frame equal to that length.  The
   media byway itself, when created, includes properties that are shared
   across all media frames within that byway.  These parameters include
   the sequence number base, the timestamp base, the codec type, and the
   frame size in milliseconds for the codec.

   This is a significantly different design than RTP, which conveys many
   repeated parameters (such as the payload type and timestamp) in every
   packet.  Instead, RIPP extracts information that will be shared
   across many packets and associates it with the byway itself.  This
   means the media frames only contain the information which varies -
   the sequence number and length.  [[OPEN ISSUE: we could maybe even
   eliminate the sequence number by computing it from offset in the
   stream.  Worried about sync problems though?]]

   Consequently, each media frame has the following properties:

   o  The sequence number, which is equal to the sequence number base
      associated with the media byway, PLUS the value of the sequence
      number offset

   o  The timestamp, which is equal to the timestamp base from the
      byway, PLUS the sequence number offset TIMES the frame size in
      milliseconds.  Note that this requires that frame size must remain
      fixed for all media frames in a byway.

   o  The codec type, which is a fixed property of the byway.  There are
      no payload type numbers in RIPP.

   RIPP does not support gaps in the media sequence due to silence.
   Something must be transmitted for each time interval.  If a RIPP
   implementation wishes to change codecs, it MUST utilize a different
   byway for</font></strong> that <strong><font color='green'>codec.

8.7.  Opening Media Byways

   The client bears</font></strong> the <strike><font color='red'>call</font></strike> <strong><font color='green'>responsibility for opening media byways - both
   forward and reverse.  Consequently, the server</font></strong> is
   <strike><font color='red'>now</font></strike> <strong><font color='green'>strongly dependent
   on the client opening reverse byways; it cannot send media unless
   they've been opened.

   A client MUST open a new forward byway whenever it has a media frame
   to send, all existing forward byways (if any) are in the blocked
   state, and the client has not yet opened 20 byways.

   Furthermore, the client MUST keep a minimum of 10 reverse byways open
   at all times.  This ensures the server can send media.  The client
   MUST open these byways immediately, in parallel.

   The use of multiple media byways in either direction is essential to
   low latency operation of RIPP.  This is because, as describe below,
   media frames are sprayed across these byways in order to ensure that
   there is never head-of-line blocking.  This is possible because, in
   HTTP3, each transaction is carried over a separate QUIC stream, and
   QUIC streams run on top of UDP.  Furthermore, a QUIC stream does not
   require a handshake to be established - creation of new QUIC streams
   is a 0-RTT process.

   The requests to create these transactions MUST include Cookie headers
   for any applicable session cookies.

   To initiate a signalling byway, the client MUST initiate a POST
   request to the call URI, and MUST include the URI parameter
   "signalling".  This request MUST NOT include any other URI
   parameters.

   To open a forward media byway, the client MUST initiate a POST
   request to the call URI, and MUST include the URI parameter "fwd-
   media".  It MUST include a RIPP-Media header field in the request
   headers.  Similarly, to open a reverse media byway, the client MUST
   initiate a POST request to the call URI, and MUST include the URI
   parameter "rev-media".  It MUST NOT includea a RIPP-Media header
   field</font></strong> in the <strike><font color='red'>start state as far as it is concerned.

   alerting: Passed from</font></strike> <strong><font color='green'>request headers.  The</font></strong> server <strike><font color='red'>to client, indicating that</font></strike> <strong><font color='green'>MUST include the RIPP-Media
   header in the response headers.  The RIPP-Media header contains the
   properties for the byway - the sequence number base, the timestamp
   base, and the name of</font></strong> the <strike><font color='red'>recipint</font></strike> <strong><font color='green'>codec.

   RIPP supports multiple channels, meant for SIPREC use cases.  Each
   channel MUST be on a separate byway.  When multi-channel audio</font></strong> is <strike><font color='red'>alerting.

   accepted: Passed from server to client, indicating that</font></strike>
   <strong><font color='green'>being used,</font></strong> the <strike><font color='red'>call was
   accepted.

   rejected: Passed from server to client, indicating that</font></strike> <strong><font color='green'>client MUST include the multi-channel parameter and
   MUST include</font></strong> the <strong><font color='green'>channel number, starting at 1.

   All RIPP implementations MUST support G.711 and Opus audio codecs.
   All implementations MUST support [RFC2833] for DTMF, and MUST support
   [RFC3389] for comfort noise, for both sending and receiving.

   The sequence number space is unique for each direction, channel, and</font></strong>
   call <strike><font color='red'>was
   rejected</font></strike> <strong><font color='green'>(as identified</font></strong> by the <strike><font color='red'>user.

   failed: Passed from server to client, indicating that the</font></strike> call <strike><font color='red'>was
   rejected by server or downstream servers, not by</font></strike> <strong><font color='green'>URI).  Each side MUST start</font></strong> the <strike><font color='red'>user, but due</font></strike>
   <strong><font color='green'>sequence number at zero, and MUST increment it by one for each
   subsequent media frame.  The sequence number base is represented as a
   string corresponding</font></strong> to
   <strike><font color='red'>some kind of error condition.  This event contains</font></strike> a <strike><font color='red'>response code</font></strike> <strong><font color='green'>32 bit unsigned integer,</font></strong> and <strike><font color='red'>reason phrase, which are identical to</font></strike> the <strike><font color='red'>response codes and
   reason phrases</font></strike> <strong><font color='green'>sequence
   number offset</font></strong> in <strike><font color='red'>SIP.

   noanswer: Passed from server to client, indicating that</font></strike> the <strong><font color='green'>media frame is variable length, representing an
   unsigned integer.  Consequently, the sequence number space for a
   media stream within a</font></strong> call <strike><font color='red'>was
   delivered to</font></strike> <strong><font color='green'>has a total space of 32 bits.  With a
   minimum frame size of 10ms, RIPP can support call durations as long
   as 11,930 hours.  Rollover of</font></strong> the <strike><font color='red'>receiving user but was</font></strike> <strong><font color='green'>sequence number is</font></strong> not <strike><font color='red'>answered, and the server
   or a downstream server timed out</font></strike> <strong><font color='green'>permitted,</font></strong>
   the <strike><font color='red'>call.

   end: initiated by either</font></strike> client or <strike><font color='red'>server, it indicates that</font></strike> <strong><font color='green'>server MUST end</font></strong> the call
   <strike><font color='red'>is to be terminated.  Note</font></strike> <strong><font color='green'>before rollover.  This means</font></strong>
   that <strike><font color='red'>this does NOT delete the HTTP
   resource, it merely changes its state to call end.  Furthermore, a
   call cannot be ended with a DELETE against</font></strike> the <strong><font color='green'>combination of</font></strong> call <strike><font color='red'>URI; DELETE is
   not permitted and MUST be rejected by the server.

   migrate: sent from server</font></strike> <strong><font color='green'>URI, direction (client</font></strong> to <strike><font color='red'>client, it instructs the client</font></strike> <strong><font color='green'>server, or
   server</font></strong> to
   <strike><font color='red'>terminate the connections</font></strike> <strong><font color='green'>client), channel number,</font></strong> and <strike><font color='red'>restablish them to</font></strike> <strong><font color='green'>sequence number represent</font></strong> a <strike><font color='red'>new URI which
   replaces the URI</font></strike>
   <strong><font color='green'>unique identifier</font></strong> for <strike><font color='red'>the call.  The event contains the new URI to
   use.

6.8.  Signaling State Machine

6.8.1.  Client</font></strike> <strong><font color='green'>media packets.

8.8.  Sending and Receiving Media</font></strong>

   The <strike><font color='red'>call begins in</font></strike> <strong><font color='green'>approach for media is media striping.

   To avoid HOL blocking, we cannot send a second media packet on a
   byway until we are sure</font></strong> the <strike><font color='red'>CREATED state.</font></strike> <strong><font color='green'>prior media packet was received.</font></strong>  This <strike><font color='red'>state</font></strike> is <strike><font color='red'>entered the
   moment the cient receives the 201 response from the server with the
   call URI.  That creates an instance of</font></strike>
   <strong><font color='green'>why</font></strong> the <strike><font color='red'>state machine associated
   with that URI.

   The states are:

   CREATED STARTING PENDING ALERTING ANSWERED TERMINATED</font></strike> <strong><font color='green'>client opens multiple media byways.</font></strong>

   When <strike><font color='red'>in the CREATED state, when</font></strike> <strong><font color='green'>either</font></strong> the client <strong><font color='green'>or server</font></strong> sends a <strike><font color='red'>start event on the
   signaling transaction, it transitions to the STARTING state.  Once in
   the starting state, it MUST open 10 media connections.  Once it has
   opened these connections and also receive a started event from the
   server, it transitions to the PENDING state.  The receipt of an
   alerting event moves it to the ALERTING state.  From ALERTING,
   receipt of an answered event moves it to the ANSWERED state.  Receipt
   of</font></strike> <strong><font color='green'>media frame on</font></strong> a <strike><font color='red'>noanwer or failed moves</font></strike> <strong><font color='green'>byway,</font></strong> it <strike><font color='red'>to</font></strike>
   <strong><font color='green'>immediately marks</font></strong> the <strike><font color='red'>terminated state.  From any
   state, receipt</font></strike> <strong><font color='green'>byway as blocked.  At that point, it SHOULD NOT
   send another media frame on that byway.  The client</font></strong> or <strike><font color='red'>transmission of</font></strike> <strong><font color='green'>server notes
   the sequence number and channel number for that media frame.  Once it
   receives</font></strong> an <strike><font color='red'>end event moves</font></strike> <strong><font color='green'>acknowledgement for that corresponding media frame,</font></strong> it <strike><font color='red'>to</font></strike>
   <strong><font color='green'>marks</font></strong> the
   <strike><font color='red'>terminated event.</font></strike> <strong><font color='green'>byway as UNBLOCKED.</font></strong>  A <strike><font color='red'>migrate event does not change</font></strike> <strong><font color='green'>client or server MAY send a media
   frame on any unblocked byway.

   The sequence number for</font></strong> the <strike><font color='red'>state of</font></strike> <strong><font color='green'>media frame is computed based on</font></strong> the <strike><font color='red'>call; it merely
   causes</font></strike>
   <strong><font color='green'>rules described above.

   Per</font></strong> the <strike><font color='red'>client to re-initiate</font></strike> <strong><font color='green'>logic described above,</font></strong> the <strike><font color='red'>connection to</font></strike> <strong><font color='green'>client will open additional byways
   once</font></strong> the <strike><font color='red'>new URI.

6.8.2.  Server

   TODO - mirrors</font></strike> <strong><font color='green'>number of blocked byways goes above a threshold.  If a</font></strong> the <strike><font color='red'>client.

6.9.  Media

   ((TODO: this is rambling, need to split it up - introduce channels,
   command channel, relationships between all</font></strike>
   <strong><font color='green'>number</font></strong> of <strike><font color='red'>these things,
   description</font></strike> <strong><font color='green'>blocked byways in either direction hits 75%</font></strong> of the <strike><font color='red'>ack mechanism as multi-hop</font></strike> <strong><font color='green'>total</font></strong>
   for <strike><font color='red'>latency
   troubleshooting.))

   THe approach for media is media striping.  Once call</font></strike> <strong><font color='green'>that direction, this</font></strong> is <strike><font color='red'>in the
   STARTING state,</font></strike> <strong><font color='green'>a signal that congestion has occurred.
   In such a case,</font></strong> the client <strike><font color='red'>opens N (N=10 maybe? 20?) streams using N
   requests, targeted to</font></strike> <strong><font color='green'>or server MUST either drop packets at</font></strong> the <strike><font color='red'>URI associated</font></strike>
   <strong><font color='green'>application layer, or buffer them for later transmission.  [[TODO:
   can we play</font></strong> with <strong><font color='green'>QUIC priorities to prioritize newer media frames
   over older?]]

   When a client or server receives a media frame, it MUST send an
   acknowledge message.  This message MUST be sent on</font></strong> the <strike><font color='red'>call.  As with
   signaling, these are long lived for</font></strike> <strong><font color='green'>same byway on
   which</font></strong> the <strike><font color='red'>duration of</font></strike> <strong><font color='green'>media was received.  This acknowledgement message MUST
   contain</font></strong> the <strike><font color='red'>call</font></strike> <strong><font color='green'>full sequence number</font></strong> and
   <strike><font color='red'>establish a bidirectional data stream.

   To avoid HOL blocking, we cannot send a second</font></strike> <strong><font color='green'>channel number for the</font></strong> media
   packet <strike><font color='red'>on a
   stream until we are sure</font></strike> <strong><font color='green'>that was received.  It MUST also contain the timestamp,
   represented as wallclock time, at which</font></strong> the <strike><font color='red'>first</font></strike> media packet was
   received.  <strike><font color='red'>This</font></strike>

   <strong><font color='green'>If the server has marked 75% of the reverse media byways as blocked,
   it MUST send a signaling event instructing the client to open another
   reverse media byway.  Once this command</font></strong> is <strike><font color='red'>why we</font></strike> <strong><font color='green'>received, the client MUST</font></strong>
   open <strike><font color='red'>N streams.</font></strike> <strong><font color='green'>a new reverse byway, unless the total number of byways has
   reached 20.</font></strong>

   A <strong><font color='green'>client MAY terminate</font></strong> media <strike><font color='red'>packet is</font></strike> <strong><font color='green'>byways gracefully if they have not</font></strong> sent
   <strong><font color='green'>or received packets</font></strong> on <strike><font color='red'>a stream by the
   client.  Once it is sent,</font></strike> that <strike><font color='red'>stream</font></strike> <strong><font color='green'>byway for 5 or more seconds.  This is to
   clean up unused byways.

   There</font></strong> is no <strike><font color='red'>longer used</font></strike> <strong><font color='green'>need</font></strong> for <strike><font color='red'>media.
   Once the other side receives</font></strike> <strong><font color='green'>sender or receiver reports.  The equivalent
   information is knowable from</font></strong> the <strike><font color='red'>media packet, it sends back an
   application-layer ack that informs</font></strike> <strong><font color='green'>application layer acknowledgements.

8.9.  Terminating and Re-establishing Connections and Byways

   The state of</font></strong> the <strike><font color='red'>sender that</font></strike> <strong><font color='green'>connection,</font></strong> the <strike><font color='red'>media packet
   was receivd</font></strike> <strong><font color='green'>QUIC streams,</font></strong> and <strike><font color='red'>therefore there</font></strike> <strong><font color='green'>byways,</font></strong> is <strike><font color='red'>no blocking on that stream.</font></strike>
   <strong><font color='green'>separate from the state of the call.</font></strong>  The
   <strike><font color='red'>sender</font></strike> <strong><font color='green'>client MAY terminate an
   HTTP connection or byway at any time, and re-establish it.
   Similarly, the server or client</font></strong> may <strike><font color='red'>then once again use that stream.  This causes</font></strike> <strong><font color='green'>end the a byway at any time.

   If a byway ends or the connection breaks or is migrated, the client
   MUST re-initiate the byways immediately, or risk loss of</font></strong> media
   <strike><font color='red'>packets</font></strike> <strong><font color='green'>and
   signalling events.  However,</font></strong> to <strike><font color='red'>be sprayed across</font></strike> <strong><font color='green'>deal with</font></strong> the <strike><font color='red'>streams sequentially.  The number of
   streams</font></strike> <strong><font color='green'>fact</font></strong> that <strike><font color='red'>must be opened to ensure no HOL blocking</font></strike> <strong><font color='green'>re-
   establishment takes time, both client and server MUST buffer their
   signalling and media streams for at least 5 seconds, and then once
   the connections and byways</font></strong> are <strike><font color='red'>a function</font></strike> <strong><font color='green'>re-established, it sends all buffered
   data immediately.

   Note that it is the sole responsibility</font></strong> of the <strike><font color='red'>RTT delay</font></strike> <strong><font color='green'>client to make sure
   byways are re-established if they fail unexpectedly.

8.10.  Signaling - Events

   Signaling is performed by having the client</font></strong> and <strike><font color='red'>packet loss tolerance.  ((TODO: Need some math
   here.))

   RIPP media acknowledgement packets MUST be sent on channel zero.
   Like media packets, media acknowledgement packets have</font></strike> <strong><font color='green'>server exchange
   events.  Each event is a JSON object embedded in the signalling
   stream, which conveys the event as perceived by the client or server.
   Each event has</font></strong> a sequence number, <strong><font color='green'>which starts at zero for</font></strong> a <strike><font color='red'>payload type,</font></strike> <strong><font color='green'>call,</font></strong>
   and <strike><font color='red'>a reserved it.</font></strike> <strong><font color='green'>increases by one for each event.</font></strong>  The <strike><font color='red'>mapping of payload
   types to object structure</font></strike> <strong><font color='green'>sequence number space</font></strong> is <strike><font color='red'>conveyed</font></strike>
   <strong><font color='green'>unique</font></strong> in <strong><font color='green'>each direction.  The event also contains a direction field,
   which indicates whether</font></strong> the <strike><font color='red'>Media headers upon
   opening of the transaction.  Media ackowledgement packets follow</font></strike> <strong><font color='green'>event was sent from client to server, or
   server to client.  It also contains</font></strong> a
   <strike><font color='red'>simple format.  They contain</font></strike> <strong><font color='green'>timestamp field, which
   indicates</font></strong> the <strike><font color='red'>sequence number and channel number</font></strike> <strong><font color='green'>time</font></strong> of the <strike><font color='red'>media packet being acknowledged, and</font></strike> <strong><font color='green'>event as perceived by the sender.  This
   timestamp is not updated when retransmissions happen;</font></strong> the timestamp
   <strong><font color='green'>exists</font></strong> at <strike><font color='red'>which
   that media packet was received by</font></strike> the <strike><font color='red'>endpoint,</font></strike> <strong><font color='green'>RIPP application layer</font></strong> and <strong><font color='green'>RIPP cannot directly observe
   HTTP retransmits.

   It also contains</font></strong> a <strike><font color='red'>flag indicating
   whether</font></strike> <strong><font color='green'>call field, which contains</font></strong> the <strike><font color='red'>endpoint dropped</font></strike> <strong><font color='green'>URI of</font></strong> the <strike><font color='red'>media packet or sent it onwards.

   This protocol also supports conveyance</font></strike> <strong><font color='green'>call in
   question.

   Finally, there is an event type field, which conveys the type</font></strong> of <strike><font color='red'>ack messages that indicate
   packet disposition at downstream and upstream endpoints.  If a RIPP
   server acts as a RIPP client, and sends a packet</font></strike>
   <strong><font color='green'>event.  This is followed by additional fields which are specific</font></strong> to
   the <strike><font color='red'>next-hop RIPP
   server,</font></strike> <strong><font color='green'>event type.

   This structure means that each event carried in the signalling is
   totally self-describing, irregardless of</font></strong> the <strike><font color='red'>RIPP client will receive</font></strike> <strong><font color='green'>enclosing connection and
   stream.  This greatly facilitates logging, debugging,
   retransmissions, retries, and other race conditions which may deliver
   the same event multiple times, or deliver</font></strong> an <strike><font color='red'>acknowledgement for that
   packet.  Once received, it adds a hop counter (in this case,</font></strike> <strong><font color='green'>event to</font></strong> a <strike><font color='red'>hop
   count</font></strike> <strong><font color='green'>server which
   is not aware</font></strong> of <strike><font color='red'>1) and passes</font></strike> the <strike><font color='red'>ACK upstream.  In addition, if</font></strike> <strong><font color='green'>call.

   Events are also defined so that</font></strong> the <strike><font color='red'>RIPP
   client receives an ACK with a hop count greater than 0, it increments</font></strike> <strong><font color='green'>resulting state is uniquely
   defined by</font></strong> the <strike><font color='red'>hop count and passes it upstream.

   For this to be effective, RIPP servers acting as clients MUST NOT
   perform sequence renumbering.

   A RIPP endpoint</font></strike> <strong><font color='green'>event itself.  This ensures</font></strong> that <strike><font color='red'>receives a media packet on a stream will not
   know whether this packet had been retransmitted or not.  However, it
   can compute</font></strike> <strong><font color='green'>knowing</font></strong> the <strike><font color='red'>time of transmission</font></strike> <strong><font color='green'>most
   recent event is sufficient to determine the state</font></strong> of the <strike><font color='red'>media packet, as</font></strike> <strong><font color='green'>call.

   This specification defines</font></strong> the
   <strike><font color='red'>timestamp of</font></strike> <strong><font color='green'>following events:

   alerting: Passed from server to client, indicating that</font></strong> the <strike><font color='red'>start of</font></strike> <strong><font color='green'>recipient
   is alerting.

   accepted: Passed from server to client, indicating that</font></strong> the <strike><font color='red'>transaction, times</font></strike> <strong><font color='green'>call was
   accepted.

   rejected: Passed from server to client, indicating that</font></strong> the <strike><font color='red'>difference
   between</font></strike> <strong><font color='green'>call was
   rejected by</font></strong> the <strike><font color='red'>first and most recent sequence numbers, times</font></strike> <strong><font color='green'>user.

   failed: Passed from server to client, indicating that</font></strong> the <strike><font color='red'>framing
   for</font></strike> <strong><font color='green'>call was
   rejected by server or downstream servers, not by</font></strong> the <strike><font color='red'>codec.  ((TODO: hmm this means we need fixed framing if we
   want</font></strike> <strong><font color='green'>user, but due to
   some kind of error condition.  This event contains a response code
   and reason phrase, which are identical</font></strong> to <strike><font color='red'>avoid adding timestamps)).  With this information it can
   compute</font></strike> the <strike><font color='red'>one way hop delay, accurate</font></strike> <strong><font color='green'>response codes and
   reason phrases in SIP.

   noanswer: Passed from server</font></strong> to <strike><font color='red'>within the clock delta
   between the sender and receiver.  Based on these, it can can
   determine whether</font></strike> <strong><font color='green'>client, indicating that</font></strong> the <strike><font color='red'>incremental hop delay is small enough</font></strike> <strong><font color='green'>call was
   delivered</font></strong> to <strike><font color='red'>merit
   continued transmission of</font></strike> the <strike><font color='red'>media packet.

   After a client sends</font></strike> <strong><font color='green'>receiving user but was not answered, and</font></strong> the <strike><font color='red'>headers for a media transaction, it MAY
   immediately send</font></strike> <strong><font color='green'>server
   or</font></strong> a <strike><font color='red'>single media packet.  AFter that, it MUST mark</font></strike> <strong><font color='green'>downstream server timed out</font></strong> the
   <strike><font color='red'>transaction as blocked.  Once</font></strike> <strong><font color='green'>call.

   end: initiated by either client or server,</font></strong> it <strike><font color='red'>receives an acknowledgement</font></strike> <strong><font color='green'>indicates</font></strong> that the
   <strike><font color='red'>packet was received, it MUST mark</font></strike> <strong><font color='green'>call
   is to be terminated.  Note that this does NOT delete</font></strong> the <strike><font color='red'>transaction as unblocked.  A
   server behaves similarly, once</font></strike> <strong><font color='green'>HTTP
   resource,</font></strong> it <strike><font color='red'>has received the request headers
   and sent</font></strike> <strong><font color='green'>merely changes</font></strong> its <strike><font color='red'>response headers, it MAY immediately send</font></strike> <strong><font color='green'>state to call end.  Furthermore,</font></strong> a <strike><font color='red'>single media
   packet,</font></strike>
   <strong><font color='green'>call cannot be ended with a DELETE against the call URI; DELETE is
   not permitted</font></strong> and <strike><font color='red'>then it</font></strike> MUST <strike><font color='red'>mark</font></strike> <strong><font color='green'>be rejected by</font></strong> the <strike><font color='red'>transaction as blocked.  Once it
   receives an acknowledgement that</font></strike> <strong><font color='green'>server.  The call end event
   SHOULD contain a reason, using</font></strong> the <strike><font color='red'>packet was received,</font></strike> <strong><font color='green'>Reason codes defined for SIP.

   migrate: sent from server to client,</font></strong> it <strike><font color='red'>MUST
   mark</font></strike> <strong><font color='green'>instructs</font></strong> the <strike><font color='red'>transaction as unblocked.  An endpoint SHOULD NOT send a
   media packet on a blocked connection.

   IF a</font></strike> client <strike><font color='red'>reaches 75% of its media transactions as in</font></strike> <strong><font color='green'>to
   terminate</font></strong> the <strike><font color='red'>blocked
   state, it MUST begin opening new media transactions</font></strike> <strong><font color='green'>connections and re-establish them</font></strong> to <strike><font color='red'>ensure that
   media can continue</font></strike> <strong><font color='green'>a new URI which
   replaces the URI for the call.  The event contains the new URI</font></strong> to <strike><font color='red'>flow uninterrupted.  A server cannot open</font></strike>
   <strong><font color='green'>use.  This</font></strong> new
   <strike><font color='red'>connections.  However, if</font></strike> <strong><font color='green'>URI MUST utilize the same path components, and MUST
   have a different authority component.

   open-reverse: sent from server to client, it instructs</font></strong> the <strike><font color='red'>server has marked 75%</font></strike> <strong><font color='green'>client to
   open an additional set</font></strong> of <strike><font color='red'>the
   connections as blocked, it MUST</font></strike> <strong><font color='green'>reverse media byways.

   tnt:</font></strong> send <strong><font color='green'>from consumer to provider, it invokes</font></strong> a <strike><font color='red'>command on</font></strike> <strong><font color='green'>takeback-and-
   transfer operation.  It includes</font></strong> the <strike><font color='red'>media command
   channel instructing</font></strike> <strong><font color='green'>phone number to which</font></strong> the <strike><font color='red'>client</font></strike> <strong><font color='green'>call
   should be transferred.  The provide will then transfer the call</font></strong> to <strike><font color='red'>open another connection.  Once this
   command is received,</font></strike>
   the <strike><font color='red'>client MUST open a new connection.

   A client MAY terminate media transactions gracefully if they have not
   sent or received packets on that connection for 5 or more seconds.</font></strike> <strong><font color='green'>target number.</font></strong>  This <strong><font color='green'>event</font></strong> is <strong><font color='green'>meant</font></strong> to <strike><font color='red'>clean up unused transactions.

   There is no need for sender or receiver reports.  The equivalent
   information is knowable from</font></strike> <strong><font color='green'>invoke</font></strong> the <strike><font color='red'>application layer acks.

6.10.</font></strike> <strong><font color='green'>feature as it
   has been implemented by the provider.  RIPP does not define
   additional behaviors.

8.11.</font></strong>  Call Termination

   Signaling allows an application layer call end to be sent.  This will
   also cause each side to <strike><font color='red'>termiante</font></strike> <strong><font color='green'>terminate</font></strong> the <strike><font color='red'>request and media streams with</font></strike> <strong><font color='green'>the outstanding transactions
   using</font></strong> end flags per HTTP3 specs.  However, the opposite is not true -
   ending of the transactions or connection does not impact the call
   state.

   A server MUST maintain a timer, with a value equal to <strike><font color='red'>5 seconds,</font></strike> <strong><font color='green'>one second,</font></strong> for
   which it will hold the call in its current state without any active
   <strike><font color='red'>signaling transaction.</font></strike>
   <strong><font color='green'>signalling byway.</font></strong>  If the server does not receive a <strike><font color='red'>signaling
   transaction before</font></strike> <strong><font color='green'>signalling byway
   before the expiration of this timer, it MUST consider the call as
   ended.

   If the server receives a signalling or media byway for a call that is
   in the TERMINATED, it MUST reject the transaction with an XX response
   code.

   Once the call has ended, the call resource SHOULD be destroyed.

8.12.  GET Transactions

   A client MAY initiate a GET request against the call URI at any time.
   This returns the current state of the resource.  This request returns
   the most recent event, either sent by the server or received by the
   server.

8.13.  Graceful Call Migration: Server

   To facilitate operational maintenance, the protocol has built in
   support for allowing a server instance to drain all active calls to
   another server instance.

   The server can issue a migrate event over the signalling byway, which
   includes a new call URI that</font></strong> the <strike><font color='red'>expiration of this timer, it MUST consider</font></strike> <strong><font color='green'>peer should use.  Once received, the
   client closes all transactions to</font></strong> the <strong><font color='green'>current</font></strong> call <strike><font color='red'>as ended</font></strike> <strong><font color='green'>URI.  It then
   establishes new signalling, media</font></strong> and <strike><font color='red'>transition its state</font></strike> <strong><font color='green'>media control byways</font></strong> to <strike><font color='red'>TERMINATED.

   If</font></strike> the <strike><font color='red'>server receives a signaling or</font></strike> <strong><font color='green'>URI
   it just received.  All</font></strong> media <strike><font color='red'>connection for a call</font></strike> that <strong><font color='green'>the client wishes to transmit, but
   was unable to do so during the migration,</font></strong> is <strong><font color='green'>buffered and then sent</font></strong>
   in <strong><font color='green'>a burst once</font></strong> the <strike><font color='red'>TERMINATED, it MUST reject</font></strike> <strong><font color='green'>media byways are re-established.  This ensures
   there is no packet loss (though there will be jitter) during</font></strong> the <strike><font color='red'>transaction with an XX
   response code.

   Note</font></strike>
   <strong><font color='green'>migration period.

   We dont use QUIC layer connection migration, as</font></strong> that <strike><font color='red'>the</font></strike> <strong><font color='green'>is triggered by
   network changes and not likely to be exposed to applications.

8.14.  Graceful Call Migration: Client

   Clients can move a</font></strong> call <strike><font color='red'>resource itself -</font></strike> <strong><font color='green'>from one client instance to another easily.
   No commands are required.  The client simply ends</font></strong> the <strike><font color='red'>URI - still exists.  POST</font></strike> <strong><font color='green'>in-progress</font></strong>
   transactions for <strike><font color='red'>signaling</font></strike> <strong><font color='green'>signalling</font></strong> and <strike><font color='red'>media are not permitted against it
   once</font></strike> <strong><font color='green'>media, and then reinitiates them to</font></strong>
   the <strong><font color='green'>existing</font></strong> call <strike><font color='red'>is in an ended state.  However, a</font></strike> <strong><font color='green'>URI from whatever</font></strong> server <strike><font color='red'>MUST maintain
   the resource for at least one day,</font></strike> <strong><font color='green'>is</font></strong> to <strike><font color='red'>facilitate a GET request
   against it.  As described below, a GET request against a call
   resource allows</font></strike> <strong><font color='green'>take over.  Note
   that</font></strong> the client <strike><font color='red'>to catch up with</font></strike> <strong><font color='green'>MUST do this within 1s or</font></strong> the <strike><font color='red'>state of</font></strike> <strong><font color='green'>server will end</font></strong> the <strike><font color='red'>call,
   facilitating stateless migration of clients.

6.11.  GET Transactions

   A client MAY initiate a GET request against</font></strike>
   <strong><font color='green'>call.

8.15.  Ungraceful Call Migration

   Since all media packets are acknowledged at</font></strong> the <strike><font color='red'>call URI</font></strike> <strong><font color='green'>application layer, it
   is possible for endpoints to very quickly detect remote failures,
   network failures, and other related problems.

   Failure detection falls entirely</font></strong> at <strike><font color='red'>any time.
   This returns</font></strike> the <strike><font color='red'>current state</font></strike> <strong><font color='green'>hands</font></strong> of the <strike><font color='red'>resource.  This request returns
   an objet which</font></strike> <strong><font color='green'>client.  A
   failure situation</font></strong> is <strike><font color='red'>the concatenation</font></strike> <strong><font color='green'>detected when any one</font></strong> of <strike><font color='red'>all call events, sent by</font></strike> the
   <strike><font color='red'>server and received</font></strike> <strong><font color='green'>following happens:

   1.  The QUIC connection closes unexpectedly

   2.  Any outstanding signalling or media byway is reset</font></strong> by the <strike><font color='red'>server, in the order in whch the server
   applied them to the state machine.

   The response also contains a summary of</font></strike> <strong><font color='green'>peer

   3.  No</font></strong> media <strike><font color='red'>packet statistics up to
   that point ((TODO: specify)).

6.12.  Graceful Call Migration: Server

   To facilitate operational maintenance,</font></strike> <strong><font color='green'>packets are received from</font></strong> the <strike><font color='red'>protocol has built in
   support</font></strike> <strong><font color='green'>peer</font></strong> for <strike><font color='red'>allowing a server instance to drain all active calls to
   another server instance.

   The server can issue a migrate event over the signaling channel,
   which includes a new call URI</font></strike> <strong><font color='green'>1s

   4.  No acknowledgements are received for packets</font></strong> that <strong><font color='green'>have been sent
       in</font></strong> the <strike><font color='red'>peer should use.  Once
   received,</font></strike> <strong><font color='green'>last 1s

   If</font></strong> the client <strike><font color='red'>closes</font></strike> <strong><font color='green'>detects such a failure, it MUST abort</font></strong> all <strong><font color='green'>ongoing</font></strong>
   transactions to the <strike><font color='red'>current call URI.
   It</font></strike> <strong><font color='green'>server, terminate the QUIC connection, and</font></strong> then <strike><font color='red'>establishes</font></strike>
   <strong><font color='green'>establish a</font></strong> new <strike><font color='red'>signaling transactions to the URI it just
   received,</font></strike> <strong><font color='green'>connection using 0-RTT, and re-establish signalling</font></strong>
   and <strike><font color='red'>in parallel re-establishes</font></strike> media transactions.  <strike><font color='red'>All
   media received during the migration phase is buffered to ensure there
   is no packet loss (though there will be jitter) during the migration
   period.</font></strike>  If <strong><font color='green'>this retry fails,</font></strong> the <strike><font color='red'>server receives a GET request to</font></strike> <strong><font color='green'>client MUST
   consider</font></strong> the <strike><font color='red'>old</font></strike> call <strike><font color='red'>URI, it MUST
   return</font></strike> <strong><font color='green'>terminated.  It SHOULD NOT</font></strong> a <strike><font color='red'>3xx response redirecting</font></strike> <strong><font color='green'>further attempt</font></strong> to <strong><font color='green'>re-
   establish</font></strong> the <strike><font color='red'>new call URI.

   We dont use QUIC layer connection migration, as that</font></strike> <strong><font color='green'>call.

9.  Syntax

   To be filled in.

10.  SIP Gateway

   RIPP</font></strong> is <strike><font color='red'>triggered by
   network changes</font></strike> <strong><font color='green'>designed to be easy to gateway from SIP.  The expectation is
   that RIPP will be implemented in SBCs</font></strong> and <strike><font color='red'>not likely</font></strike> <strong><font color='green'>softswitches.  A SIP to
   RIPP gateway has</font></strong> to be <strike><font color='red'>exposed</font></strike> <strong><font color='green'>call-stateful, acting as a b2bua, in order</font></strong> to <strike><font color='red'>applications.

6.13.  Graceful Call Migration: Client

   Clients can move</font></strike>
   <strong><font color='green'>gateway to RIPP.  Furthermore,</font></strong> a <strike><font color='red'>call from one client instance</font></strike> <strong><font color='green'>SIP</font></strong> to <strike><font color='red'>another easily.
   No commands are required.  The client simply ends the in-progress
   transactions for signaling</font></strike> <strong><font color='green'>RIPP gateway has to act as a
   media termination point in SIP.  It has to perform any SRTP
   decryption</font></strong> and <strike><font color='red'>media,</font></strike> <strong><font color='green'>encryption,</font></strong> and <strike><font color='red'>then reinitiates them</font></strike> <strong><font color='green'>it must de-packetize RTP packets</font></strong> to
   <strike><font color='red'>the existing call URI from whatever server is</font></strike>
   <strong><font color='green'>extract their timestamps, sequence numbers, and codec types.

   SIP</font></strong> to <strike><font color='red'>take over.  Note
   that the client MUST</font></strike> <strong><font color='green'>RIPP gateways are not transparent.  SIP header fields which
   are unknown or</font></strong> do <strike><font color='red'>this within 5s</font></strike> <strong><font color='green'>not map to RIPP functionality as described here,
   MUST be discarded.

   Any configuration and provisioning for RIPP happens ahead of receipt</font></strong>
   or <strong><font color='green'>transmission of SIP calls.  Consequently,</font></strong> the <strike><font color='red'>server will end the
   call.

6.14.  Ungraceful Call Migration

   Since all media packets are acknowledged</font></strike> <strong><font color='green'>logic described here
   applies</font></strong> at the <strike><font color='red'>application layer, it
   is possible</font></strike> <strong><font color='green'>point that a gateway receives a SIP INVITE on the SIP
   side, or receives a POST to the RIPP trunk URI on the RIPP side.

   This specification does define some normative procedures</font></strong> for <strike><font color='red'>endpoints</font></strike> <strong><font color='green'>the
   gateway function in order</font></strong> to <strike><font color='red'>very quickly detect remote failures,
   network failures,</font></strike> <strong><font color='green'>maximize interoperability.

10.1.  RIPP to SIP

10.2.  SIP to RIPP

   When a gateway receives a SIP INVITE</font></strong> and <strike><font color='red'>other related problems.

   Failure detection falls entirely at</font></strike> <strong><font color='green'>decides it wants to route it
   out on a RIPP trunk, it MUST immediately reply to</font></strong> the <strike><font color='red'>hands of</font></strike> <strong><font color='green'>incoming SIP
   INVITE with a 183.  If</font></strong> the <strike><font color='red'>client.  A
   failure situation is detected when any one of</font></strike> <strong><font color='green'>INVITE contained an offer,</font></strong> the <strike><font color='red'>following happens:

   1.</font></strike> <strong><font color='green'>183 MUST
   contain an SDP answer.</font></strong>  The <strike><font color='red'>QUIC connection closss unexpectedly

   2.  Any outstanding signaling</font></strike> <strong><font color='green'>gateway MAY choose to either transcode
   incoming audio to G.711</font></strong> or <strike><font color='red'>media transactions are reset by the
       peer

   3.  No media packets are received from</font></strike> <strong><font color='green'>Opus, or it may pass through</font></strong> the <strike><font color='red'>peer for 5s

   4.  No acknowledgements are received</font></strike> <strong><font color='green'>codec
   frames without transcoding.  This specification defines procedures</font></strong>
   for <strike><font color='red'>packets that have been sent
       in</font></strike> <strong><font color='green'>passthrough.

   Next,</font></strong> the <strike><font color='red'>last 5s</font></strike> <strong><font color='green'>gateway creates an HTTP POST request towards the RIPP trunk
   URI of its peer.</font></strong>  If the <strike><font color='red'>client detects such</font></strike> <strong><font color='green'>incoming call was to</font></strong> a <strike><font color='red'>failure, it</font></strike> <strong><font color='green'>phone number, the
   gateway</font></strong> MUST <strike><font color='red'>abort all ongoing
   transactions</font></strike> <strong><font color='green'>convert it</font></strong> to <strong><font color='green'>an E.164 number an include that in</font></strong> the <strike><font color='red'>server, terminate</font></strike>
   <strong><font color='green'>target URI parameter of</font></strong> the <strike><font color='red'>QUIC connection,</font></strike> <strong><font color='green'>RIPP request.

11.  RAML API

#%RAML 1.0
---
title: RIPP
baseUri: http://ripp.example.net/{version}
version: v1
protocols: [ HTTPS ]
securedBy: [ oauth_2_0 ]

securitySchemes:
  oauth_2_0: !include securitySchemes/oauth_2_0.raml

types:
    InboundEndpoint:
        type: object
        properties:
            consumerTrunkURI: string
            consumerToken: string
    Event:
        type: object
        properties:
            name:
                enum: [ alerting, accepted, rejected, failed, tnt, migrate, terminated ]
            ended:
                type: boolean
            timeStamp:
                type: datetime
            tntDestination:
                type: string
                note: only in events with name tnt
            migrateToURl:
                type: string
                note: only in events with name migrate
     Advertisement:
        type object
        properties:
            max-bitrate: number
            max-samplerate: number
            max-channels: number
            non-e164: boolean
            force-cbr: boolean
            tnt: boolean
    Frame:
        seqNumOffset: number
        dataLen: number
        data: string
    FrameAck:
        seqNum: number
    BywayPreamble:
        baseSeqNum: number
        baseTime: number
        frameTime: number
        codec:
            enum: [ opus, g711, dtmf, cn, ack ]
     BywayMedia:
        mediaFrames: array

/trunks:
   /{trunkID}:
      /consumerTrunk:
        put:
            description: Set the URI</font></strong> and <strike><font color='red'>then
   establish</font></strike> <strong><font color='green'>security token for consumer trunk URI
            securedBy: [oauth_2_0]
      /capAdv:
        get:
            description: Get the Capability Advertisement for this trunk
            securedBy: [oauth_2_0]
            responses:
                200:
                    body:
                         application/json:
                            type: Advertisement
      /calls:
        post:
            securedBy: [oauth_2_0]
            description: Create</font></strong> a new <strike><font color='red'>connection using 0-RTT, and re-establish signaling
   and</font></strike> <strong><font color='green'>call. Returns a Call URI
            responses:
                202:

/call:
    /{callID}:
        /event:
            get:
                description: Retreive the most recent event from server
                responses:
                    200:
                        body:
                            application/json:
                                type: Event
            put:
                description: Tell server about recent event
                body:
                    application/json:
                        type: Event
                responses:
                    200:
        /media-up:
            post:
                 description: Starts an infinite flow of</font></strong> media <strike><font color='red'>transactions.

   TOOD: need to specify back-off timers and retry algorithms

7.  Detailed Protocol Semantics

   To be filled in.

8.  Syntx

   To be filled in.

9.  SIP</font></strike> <strong><font color='green'>frames from client</font></strong> to <strike><font color='red'>RIPP Gatewaying

10.  RIPP</font></strike> <strong><font color='green'>server
                 body:
                    application/octet-stream:
                        type: BywayFlow
                 responses:

                    200:
                        application/octet-stream:
                            type: BywayFlow
        /media-down:
            post:
                 description: Starts an infinite flow of media frames from server</font></strong> to <strike><font color='red'>SIP Gatewaying

11.</font></strike> <strong><font color='green'>client
                 body:
                    application/octet-stream:
                        type: BywayFlow
                 responses:
                    200:
                        application/octet-stream:
                            type: BywayFlow

12.</font></strong>  IANA Considerations

<strike><font color='red'>12.</font></strike>

<strong><font color='green'>13.</font></strong>  Security Considerations

<strike><font color='red'>13.</font></strike>

<strong><font color='green'>14.</font></strong>  Acknowledgements

<strong><font color='green'>15.  Informative References

   [I-D.ietf-quic-http]
              Bishop, M., "Hypertext Transfer Protocol Version 3
              (HTTP/3)", draft-ietf-quic-http-20 (work in progress),
              April 2019.

   [I-D.ietf-quic-transport]
              Iyengar, J. and M. Thomson, "QUIC: A UDP-Based Multiplexed
              and Secure Transport", draft-ietf-quic-transport-20 (work
              in progress), April 2019.

   [RFC2833]  Schulzrinne, H. and S. Petrack, "RTP Payload for DTMF
              Digits, Telephony Tones and Telephony Signals", RFC 2833,
              DOI 10.17487/RFC2833, May 2000,
              &lt;https://www.rfc-editor.org/info/rfc2833&gt;.

   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, "SIP: Session Initiation Protocol", RFC 3261,
              DOI 10.17487/RFC3261, June 2002,
              &lt;https://www.rfc-editor.org/info/rfc3261&gt;.

   [RFC3264]  Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model
              with Session Description Protocol (SDP)", RFC 3264,
              DOI 10.17487/RFC3264, June 2002,
              &lt;https://www.rfc-editor.org/info/rfc3264&gt;.

   [RFC3389]  Zopf, R., "Real-time Transport Protocol (RTP) Payload for
              Comfort Noise (CN)", RFC 3389, DOI 10.17487/RFC3389,
              September 2002, &lt;https://www.rfc-editor.org/info/rfc3389&gt;.

   [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.
              Jacobson, "RTP: A Transport Protocol for Real-Time
              Applications", STD 64, RFC 3550, DOI 10.17487/RFC3550,
              July 2003, &lt;https://www.rfc-editor.org/info/rfc3550&gt;.

   [RFC4855]  Casner, S., "Media Type Registration of RTP Payload
              Formats", RFC 4855, DOI 10.17487/RFC4855, February 2007,
              &lt;https://www.rfc-editor.org/info/rfc4855&gt;.

   [RFC6265]  Barth, A., "HTTP State Management Mechanism", RFC 6265,
              DOI 10.17487/RFC6265, April 2011,
              &lt;https://www.rfc-editor.org/info/rfc6265&gt;.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              &lt;https://www.rfc-editor.org/info/rfc6749&gt;.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              &lt;https://www.rfc-editor.org/info/rfc7540&gt;.

   [RFC7866]  Portman, L., Lum, H., Ed., Eckel, C., Johnston, A., and A.
              Hutton, "Session Recording Protocol", RFC 7866,
              DOI 10.17487/RFC7866, May 2016,
              &lt;https://www.rfc-editor.org/info/rfc7866&gt;.

   [RFC8224]  Peterson, J., Jennings, C., Rescorla, E., and C. Wendt,
              "Authenticated Identity Management in the Session
              Initiation Protocol (SIP)", RFC 8224,
              DOI 10.17487/RFC8224, February 2018,
              &lt;https://www.rfc-editor.org/info/rfc8224&gt;.</font></strong>

Authors' Addresses

   <strong><font color='green'>Jonathan Rosenberg
   Five9

   Email: jdrosen@jdrosen.net</font></strong>
   Cullen Jennings
   Cisco Systems

   Email: fluffy@iii.ca

   <strike><font color='red'>Jonathan Rosenberg
   Five9

   Email: jdrosen@jdrosen.net</font></strike>
</pre>
</body></html>
