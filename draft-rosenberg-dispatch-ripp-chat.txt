



Network Working Group                                  J. Rosenberg, Ed.
Internet-Draft                                                     Five9
Intended status: Standards Track                        February 7, 2020
Expires: August 10, 2020


                 Web API for Persistent Messaging Apps
                 draft-rosenberg-dispatch-ripp-chat-00

Abstract

   This specification defines a web-based application protocol that
   enables interoperability for modern enterprise and consumer
   applications that provide persistent group chat capabilities.  It
   outlines the protocol capabilities needed for a union of the features
   provided across iMessage, Slack, and Webex Teams.  The specification
   enables many use cases in which interoperability is desirable,
   including enterprises that have deployed a multiplicity of these
   applications, contact center clients seeking to integrate with a
   large number of enteprise telephony systems, inter-company chat, and
   interop between consumer chat apps like iMessage and WeChat.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on August 10, 2020.

Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents



Rosenberg                Expires August 10, 2020                [Page 1]

Internet-Draft                  RIPP Chat                  February 2020


   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   2
   2.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Instances . . . . . . . . . . . . . . . . . . . . . . . . . .   4
   4.  The Chat Service  . . . . . . . . . . . . . . . . . . . . . .   6
     4.1.  Chats . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     4.2.  Retrieving Messages . . . . . . . . . . . . . . . . . . .   9
     4.3.  Participant Management  . . . . . . . . . . . . . . . . .  12
       4.3.1.  Adding, Removing and Listing Participants . . . . . .  12
       4.3.2.  Guest Access  . . . . . . . . . . . . . . . . . . . .  12
     4.4.  Posting Messages and Files  . . . . . . . . . . . . . . .  13
     4.5.  Read and Delivery Receipts  . . . . . . . . . . . . . . .  14
     4.6.  Unread Message Counters and Read Markers  . . . . . . . .  16
     4.7.  Typing Indicators . . . . . . . . . . . . . . . . . . . .  17
     4.8.  Files in a Chat . . . . . . . . . . . . . . . . . . . . .  18
     4.9.  Message Edit and Delete . . . . . . . . . . . . . . . . .  18
     4.10. Threads . . . . . . . . . . . . . . . . . . . . . . . . .  19
     4.11. Pinned Content  . . . . . . . . . . . . . . . . . . . . .  19
   5.  Profile, Users and Directory  . . . . . . . . . . . . . . . .  19
   6.  Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . .  21
   7.  Presence  . . . . . . . . . . . . . . . . . . . . . . . . . .  22
   8.  Deep Links  . . . . . . . . . . . . . . . . . . . . . . . . .  23
   9.  Interoperability Use Cases  . . . . . . . . . . . . . . . . .  24
     9.1.  Consumer to Consumer Interop  . . . . . . . . . . . . . .  24
     9.2.  Intra-Domain Enterprise Chat Federation . . . . . . . . .  25
     9.3.  Inter-Company Chat  . . . . . . . . . . . . . . . . . . .  26
   10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  26
   11. Security Considerations . . . . . . . . . . . . . . . . . . .  26
   12. Informative References  . . . . . . . . . . . . . . . . . . .  26
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  27

1.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.






Rosenberg                Expires August 10, 2020                [Page 2]

Internet-Draft                  RIPP Chat                  February 2020


2.  Introduction

   Chat and presence applications have existed for many years on the
   Internet, and have been the subject of much standardization activity.
   Most recently, the SIMPLE suite of specifications were produced,
   targeting SIP-based systems [RFC6914], along with XMPP [RFC6120].
   These specifications were produced many years ago, and since then,
   chat applications have evolved.  In enterprise, persistent chat (also
   known as team chat) has become popular, commercialized with
   applications such as Slack, Webex Teams, Microsoft Teams, Zoom, and
   others.  For consumers, iMessage, Facebook Messenger, WhatsApp, and
   WeChat are widely deployed and used.

   None of these products utilize standards-based protocols.  This has
   not prevented any of them from being widely successful.  However, it
   has introduced some use cases that are problematic.

   Within enterprises, it has become commonplace for multiple enterprise
   chat applications to exist and be deployed.  This happens because
   some applications are focused on groups of users (such as
   developers), while others are more general purpose.  It is also not
   uncommon for a department to choose one application, and for the
   company to choose a different.  This forces users to migrate, a
   painful process which often never happens.  Another similar case is
   when a company wishes to migrate from the product of one vendor, to
   another vendor.  The transition period requires both applications to
   co-exist, creating a painful process.

   Another common problem is integration.  Almost all of the vendors
   today offer web-based APIs for integrating into their platforms.
   Though they share some similarities, each are different, increasing
   the costs of integrations which support all of them.  One common use
   case is for contact center agents.  These agents typically utilize
   their own desktop applications, which are highly specialized and
   provided by different vendors.  Yet, agents are required to chat with
   users throughout the rest of the company.  Today, this is
   problematic, requiring custom-built integrations, cross-launches, or
   multiple conflicting applications on the desktop.

   For consumers, the lack of interoperability between chat apps - such
   as iMessage and WhatsApp - is well known.  Though there are reasons
   for this which are not technical in nature, it is also the case that
   there is no specification which would easily facilitate such
   interoperation.

   This document is - to a large degree - a thought experiment on what a
   standardized protocol would look like, in order to rememdy these
   deficiencies.  Generally speaking, modern web applications are



Rosenberg                Expires August 10, 2020                [Page 3]

Internet-Draft                  RIPP Chat                  February 2020


   largely not the subject of standardization, and thus it is unclear if
   the industry really wants or needs a standardized protocol here.
   Thus, this document is a strawman and an attempt to determine if in
   fact there is inerest in standards activity in this space.

   This document is more of an outline of the protocol than an actual
   interoperable specification.  It focuses on examples and use cases,
   and lacks any formalized syntax or normative behaviors.  Those would
   follow on should this document move forward.

   As a target for this thought experiment, the protocol provides the
   functionality that is sufficient to enable the union of the features
   provided in three applications - Webex Teams, Slack, and iMessage.
   This is only because the author is a regular user of all three,
   facilitating an easy analysis.  The analysis is solely done based on
   visual observation of the features of these products, and
   consequently, only reflects those visible to the author of this
   document.  The functionality provided includes instances (Teams in
   Slack parlance), persistent chat, text, image, HTML, GIF, note, and
   video messages, threading, delivery and read-receipts, unread
   markers, unread message counts, chat moderation and locking, chat
   group membership management, content pinning, favorites, deep-links,
   presence, directory, do-not-disturb, and user profile capabilities.
   A basic guest construct is introduced.  That, combined with common
   techniques for user invitation and authentication, enable inter-
   domain and intra-domain federation as well, without further
   standardization work.

   Since this is nothing more than a web application, it is fully
   specified through its definition of web resources and the affects of
   GET, PUT, POST, and DELETE on those resources, along with JSON-based
   object models for those resources.  The protocol is not focused on
   optimization, and without a doubt faster protocols could be defined.
   Rather, this protocol focuses on consistency, simplicity and minimum
   functionality, at the expense of requiring clients to perhaps make
   more queries than a more optimized protocol.

3.  Instances

   An instance refers to a unique instance of a chat application.  Each
   instance has its own set of users, chats, and so on.  In Slack, this
   is referred to as a "Team".  The name team means something different
   in Webex Teams, so we use a more descriptive term that is vendor
   agnostic.

   The primary functions needed are are for a user to enumerate the
   teams they have access to, and for each, get the name and icon for
   the team.  To do this, a "/instances" resource would exist on the



Rosenberg                Expires August 10, 2020                [Page 4]

Internet-Draft                  RIPP Chat                  February 2020


   well-known root URI for the resources defined here.  A POST would
   create a new instance.  GET would enumerate all of them with a list
   structure.  For example, to get a list of instances:

     GET example.com/.well-known/ietf-chat/instances


   This would return:

    {
     "instances" : [ {
       "name" : "marketing",
       "uri" : "https://example.com/.well-known/ietf-chat/instances/23",
       "img" : "https://example.com/files/marketing-example-image.jpg"
       },{
       "name" : "company",
       "uri" : "https://example.com/.well-known/ietf-chat/instances/38",
       } ]
    }


   If a service didnt support the notion of instances, it would simply
   not implement this resource, or return a single value rather than a
   list.

   If an instance existed, all subsequent operations in this
   specification would live underneath the URI for that instance.

   For the "/instances" resource - and indeed for all resources in this
   document - a sub-resource called "events" exists.  A client can
   perform a long lived GET against this sub-resource.  The server will
   return a streaming JSON object which includes events against the
   resource.  These events convey only the URI for the sub-resource
   which has changed.  In the case of "/instances", if a user had been
   added to a new instance, it would receive an event with the URI of
   the new instance.  The client could then query this URI and obtain
   the information about the new instance.  Similarly, if an instance
   were deleted, the user would receive an event with the URI of the
   instance that was deleted.  A query against it would return a 404,
   informing the client that the instance has been deleted.
   Alternatively the client could simply re-query "/instances" with a
   GET for the complete list.

   Performing a GET against an instance URI provides the client with the
   key information and services across the instance.  For example, with
   the list of instances above in hand, a client can fetch information
   about one of them:




Rosenberg                Expires August 10, 2020                [Page 5]

Internet-Draft                  RIPP Chat                  February 2020


     GET https://example.com/.well-known/ietf-chat/instances/23,


   and the response might be:

     {
      "uri" : "https://example.com/.well-known/ietf-chat/instances/23",
      "img" : "https://example.com/files/marketing-example-image.jpg"

      "chats" : "https://example.com/.well-known/ietf-chat/chats/23",
      "users": "https://example.com/.well-known/ietf-chat/profs/23",
      "presence":"https://example.com/.well-known/ietf-chat/pres/23",
      "lists":"https://example.com/.well-known/ietf-chat/lists/23",
     }


   In this case, the instance supports chat, user and directory
   services, presence services, and list services.  Each includes the
   URI for accessing those serices.  In general, this specification
   avoids defining the structure of URIs, and instead returns URIs as
   values.  This follows the HATEOAS principle.

4.  The Chat Service

4.1.  Chats

   The chats resource represents all of the chats available to the user.
   A chat is used to model 1-1 conversations (of which there is often
   just one instance between a pair of users), multi-user chats, as well
   as named channels.

   A GET to chats would return the list of chats.  For each chat, there
   is sufficient meta-data to render the chat in a list of chats.  These
   include "name", and "img".  To facilitate rendering if chats in order
   of most recent post, there is also a "last-updated" parameter which
   specifies the time it was last updated.  To facilitate clients
   performing catch-up queries to retrieve the changed chats since last
   time it had been synchronized, a client can include a "since" and
   "until" parameter that is used to filter the response based on the
   value of the "last-updated" parameter.  Omitting both "since" and
   "until" would perform a full refresh (which of course would be
   paginated).  Omitting "since" but including "until", and using a
   value for "until" which matches the value of "last-updated" in the
   most recent chat, would return all chats which had some kind of new
   message since the last one on the client.  Providing "since" and
   "until" allows for time-ranged based queries.





Rosenberg                Expires August 10, 2020                [Page 6]

Internet-Draft                  RIPP Chat                  February 2020


   The result of the GET to chats in all cases is a paginated list of
   chats.  For example:

     {
      "chats" : [ {
        "name" : "sales-kickoff",
        "uri" : "https://example.com/.well-known/ietf-chat/chats/abbx",
        "last-updated" : "2020-02-01T23:02:26+00:00"
        },{
        "name" : "all-company",
        "uri" : "https://example.com/.well-known/ietf-chat/chats/299ak",
        "last-updated" : "2020-02-01T22:01:18+00:00"
        } ]
     }


   A chat itself has many attributes.  These include "name", "uri",
   "img" and "last-updated" - same as returned in the list of chats.
   Its core sub-resources are "messages" which is the ordered list of
   messages in the chat, "participants" which specifies the
   participants, "policy" which specifies the policy for the chat,
   "files" for the files sent in the chat, "links" for the links in the
   chat, "threads" for the threads and "favorites" for the pinned
   objects.  As with all objects, it can be extended with proprietary
   features unique to the vendor - i.e., "whiteboards" for Webex Teams.

   The JSON object returned in a response to a GET against the chat
   resource might look something like this:























Rosenberg                Expires August 10, 2020                [Page 7]

Internet-Draft                  RIPP Chat                  February 2020


{
 "name" : "sales-kickoff",
 "uri" : "https://example.com/.well-known/ietf-chat/chats/1",
 "policy" : {
  "participants" : "all-participants",
  "messages-create" : "all-participants",
  "messages-modify" : "creator",
  "messages-delete" : "admin"
   },
 "messages":"https://example.com/.well-known/ietf-chat/chats/1/m",
 "participants":"https://example.com/.well-known/ietf-chat/chats/1/p1",
 "read-receipts":"https://example.com/.well-known/ietf-chat/chats/1/rr",
 "delivery-receipts":"https://example.com/.well-known/ietf-chat/chats/1/dr",
 "typing-indicators":"https://example.com/.well-known/ietf-chat/chats/1/ti",
 "files":"https://example.com/.well-known/ietf-chat/chats/1/fi",


 "last-updated" : "2020-02-01T23:02:26+00:00"
}


   Note how the JSON contains references to the URIs for messages, and
   participants, rather than embedding them.  This is one example where
   simplicity is favored over optimization.  This is done in part in
   expectation of HTTP2.0 deployment, which removes much of the overhead
   that is normally suffered in dereferencing lists.  It also
   facilitates interoperability in cases different services provide
   different features.  If one vendor has the notion of "links" but
   another does not, the "links" URI would simply be absent from the
   chat object.  This interoperability works the other way as well; a
   client which doesnt understand the notion of "links" would just
   ignore this object in the result.

   In a similar way, optional features like read receipts, delivery
   receipts, typing indicators and so on, are indicated by URIs which
   can be used by clients to use those features.

   Policy is one area in which existing products have differing
   capabilities.  For example, Webex Teams has the notion of a locked
   (or moderated) space, wherein only the moderators and add and remove
   participants, or delete messages.  On the other hand, Slack has the
   notion of instance-wide channels which can be joined by anyone, a
   concept which doesnt exist in Webex Teams.  To model these
   variations, the "policy" object describes the rules of the chat based
   on a series of permissions.  These permissions are rooted on the core
   objects of the chat - participants, messages, files, links,
   favorites.  For each of those, permissions can be sub-typed by
   create, update or delete.  For each permission, it can be granted to



Rosenberg                Expires August 10, 2020                [Page 8]

Internet-Draft                  RIPP Chat                  February 2020


   everyone in the chat "all-participants", everyone in the instance
   "all-instance", the admins of the instance "admins", no one "none" or
   a list of users, by URI (see below).

   To retrieve the list of messages, participants, links and so on - a
   GET to the associated URI is performed.  This query also supports the
   "since" and "until" parameters, allowing for catch ups wherein the
   client can obtain only changes since the last sync.  This is
   particularly useful for "messages" but can also come in handy for
   "participants" in chats with many, many members.

   As with "/instances", the chats resource supports a sub-resource
   called "/events" which generates events for adds, removes, and
   changes to any message, particpant, link, etc. in the chat.

   Creating a new chat is accomplished by POSTing to chats, which
   returns a body including the chat object in JSON (including of course
   its URI).  The response would be a 201 if a new chat is created, 200
   if its actually an existing one.  When creating a chat, URI
   parameters can be present to specify participants and/or a name.  In
   a product like Slack, which has the notion of a single chat for named
   set of participants, a POST to chats with a list of names that
   corresponds to an existing chat with those users, would return the
   URI for that chat.  In the case of Webex Teams, it would create a new
   chat and thus return a new URI for a new chat.  This allows server-
   side decision making on how the service works.  To create a channel
   in slack, wherein only a channel name is needed, only the "name" URI
   parameter would be present.

   Deleting a chat is accomplished with DELETE against the chat object.
   As with this request and all others, the server would authorize
   whether the client is permitted to perform the action.

4.2.  Retrieving Messages

   A GET to the messages URI learned from the chat object returns the
   list of messages in the chat.  The uri parameters "from" and "since"
   permit time-ranged based queries.  A message object is, like
   everything else, identified by a URI.  Each message has a creator and
   a timestamp.  It then has a list of one or more components, which can
   be text, links, images (either inline or links), videos, and so on.
   The usage of a list enables (for example) posting an image with
   accompanying text, a common feature in modern chat apps.

   As an example:

     GET https://example.com/.well-known/ietf-chat/chats/1/m




Rosenberg                Expires August 10, 2020                [Page 9]

Internet-Draft                  RIPP Chat                  February 2020


   would return:

       [{
        "timestamp":"2020-02-01T23:02:26+00:00",
        "creator":"https://example.com/.well-known/ietf-chat/users/8as",
        "uri":""https://example.com/.well-known/ietf-chat/chats/1/m23",

        "components" [
          {
           "type":"text/plain",
           "embed":"Check out ths cat!"
          },
          {
           "type":"image/jpeg",
           "link":"https://example.com/.well-known/ietf-chat/files/h98s"
          } ]
       }]



   In this case, the chat has one message.  For this message, the image
   is referenced by hyperlink, whereas the text is embedded.

   It is common for users to attach files (such as an Adobe PDF file or
   Microsoft Powerpoint file).  Thumbnails (pre-rendered images) for the
   files can be provided through the thumnail parameter:

























Rosenberg                Expires August 10, 2020               [Page 10]

Internet-Draft                  RIPP Chat                  February 2020


    [{
     "timestamp":"2020-02-01T23:02:26+00:00",
     "creator":"https://example.com/.well-known/ietf-chat/users/8as",
     "uri":""https://example.com/.well-known/ietf-chat/chats/1/m23",

     "components" [
       {
        "type":"application/vns.ms-powerpoint",
        "link":"https://example.com/.well-known/ietf-chat/files/aa9w",
        "thumbnail": [
           {
            "uri":"https://example.com/.well-known/ietf-chat/files/9a9kk",
            "page": 1,
            "pages": 2,
            "type": "image/jpeg"
           },
           {
            "uri":"https://example.com/.well-known/ietf-chat/files/-99Hn",
            "page": 2,
            "pages": 2,
            "type": "image/jpeg"
           },

       } ]
    }]



   To learn about new messages in a chat, the client performs a GET to
   the /events sub-resource of the messages URI or chat URI (the latter
   also performing notifications of participant changes, policy changes
   and so on).  As with others above, this returns a stream of JSON
   objects which contain only the URI for the message which has been
   added, removed or changed.

   This design means that, if a user is in 20 chats, and they wish to
   receive updates of new messages in all of them, they would require 20
   long-lived GET transactions.  THis provides flexibility in client
   design - allowing one client to receive only messages for a subset of
   chats at its discretion.  Note that a client will laern about which
   chats have any new messages via a GET on /events on the chats URI,
   even for ones that it is not performing a GET against for its events.
   This provides a baseline client design wherein a client only performs
   a GET against /events for the chat which is visible in the UI.







Rosenberg                Expires August 10, 2020               [Page 11]

Internet-Draft                  RIPP Chat                  February 2020


4.3.  Participant Management

4.3.1.  Adding, Removing and Listing Participants

   A user can add and remove users from a chat using the participants
   URI, learned from the chat object.  To retrieve the current list of
   participants, the user performs a GET against the participants URI.
   To add a user, the client performs a POST against this URI, and
   includes in the body the URI of the user:


        POST https://example.com/.well-known/ietf-chat/chats/1/p1

      {
        "user" : "https://example.com/.well-known/ietf-chat/users/8as",
      }



   The response is a 201 Created response, with a Location header field
   that includes the URI of the participant just created.  To remove
   this participant from the chat, the client can perform a DELETE
   against this URI.

   The server will typically perform authorization to determine if the
   membership management operations are permitted.  A chat where
   membership additions is limited to a list of moderators, for example,
   would be rejected if the user was not a moderator.

4.3.2.  Guest Access

   A client can also add a participant that is not part of the system,
   by including their email address or E164 number rather than a user
   URI:


        POST https://example.com/.well-known/ietf-chat/chats/1/p1

      {
        "email" : "jdrosen@example.com"
      }



   This request will also create a participant object, but have the side
   effect of sending that user an invitation to the service as a guest.
   The email (or SMS if a phone number was provided) will contain a
   well-known guest URI that looks like this:



Rosenberg                Expires August 10, 2020               [Page 12]

Internet-Draft                  RIPP Chat                  February 2020


  https://example.com/.well-known/ietf-chat-invitations/9aks00g8a6s/index.html


   The usage of a dedicated well-known URI for these invitations is
   essential to many interoperability use cases, as described below.  A
   GET to this URI - invoked only if the end user actually clicks on the
   link - would take the user to an HTML page for a guest login process,
   download of the client, and so on.

   However, to automate guest access, if this URI is understood by the
   email or SMS application, the email or SMS application would strip
   the index.html part and perform a GET query against the rest of it.
   The server would respond with a JSON object that provides the client
   with a JWT token that it can use to access that service.  Using the
   token, it would query the "/instances" resource against the well-
   known chat service URI for the authority in the URI above.  It would
   then automatically create a profile in each instance, using the
   profile data stored in the client (or retrieved from another
   instance).  It would then be able to retrieve its list of chats,
   which would incldue the one it was just added to.

4.4.  Posting Messages and Files

   Adding a message to a chat is accomplished via a POST to the messages
   URI.  The body can be any MIME type.  If no body is present, it can
   be specified by reference using the Location header field in the
   request.

   In a similar way, a client can add a file to the messaging service by
   performing a POST to the files resource of the instance.  In this
   case, the file isnt posted into any chat or otherwise become
   available for others to download.  It merely provides a way for
   clients to then add the associated content to a chat by reference,
   rather than by value.  Adding a message to a chat by reference would
   then create any of the permissions needed for other clients in the
   chat to download that file (by virtue of being in the chat).

   As an example, to upload the cat image with a caption, the client
   would first add the file:

     POST example.com/.well-known/ietf-chat/files
     Content-Type: image/jpeg

     {image content}


   The response would then indicate the URI which points to the file
   that was just uploaded:



Rosenberg                Expires August 10, 2020               [Page 13]

Internet-Draft                  RIPP Chat                  February 2020


     201 Created
     Location: https://example.com/.well-known/ietf-chat/files/h98s



   Then, the client can send the cat image with the caption thusly:


        POST https://example.com/.well-known/ietf-chat/chats/0e87

      {
        "components" : [
          {
           "type":"text/plain",
           "embed":"Check out ths cat!"
          },
          {
           "type":"image/jpeg",
           "link":"https://example.com/.well-known/ietf-chat/files/h98s"
          } ]
      }



   The response to this provides the client with the reference to this
   message, in the 201 Location header field of the response, and
   duplicated in the body.  The server assigns the creator, timestamp
   and URI fields, removed by the server if they were present in the
   request.

   This basic mechanism also allows for server side thumbnail creation.
   The client would add the powerpoint file to the "/files" resource.
   The server would perform the thumnail creation behind the scenes.
   When the client then posts the message with the reference to the
   powerpoint file, the server recognizes this, and adds the thumbnail
   links in the JSON in the response.

4.5.  Read and Delivery Receipts

   When a client receives a message, it can post a delivery receipt.
   And when it reads one, it can post a read receipt.  These are simple
   objects which refer to the message which has been delivered or read.
   For example, to add a read receipt for that cat message:








Rosenberg                Expires August 10, 2020               [Page 14]

Internet-Draft                  RIPP Chat                  February 2020


POST https://example.com/.well-known/ietf-chat/chats/1/rr
{
 "message":"https://example.com/.well-known/ietf-chat/chats/1/messages/3"
 "timestamp":"2020-02-01T23:02:26+00:00",
}



   Note that the URI against which the post has been made is learned
   from the "read-receipts" attribute of the chat object.

   Other clients can learn of read receipts in two ways.  The first is
   to perform a long running GET to /events sub-resource of the delivery
   receipts or read receipts resources on the chat URI.  These deliver
   only delivery and read receipts respectively.  The /events resource
   of the messages or chat URI however does not provide notifications of
   read receipts.  This provides clients a choice in how much
   notification traffic to receive.

   The other way is by performing a GET against the messages resource.
   The server will not actually include read-receipts as standalone
   messages, but rather, add the "read-receipts" or "delivery-receipts"
   attributes to each message which has had delivery or read receipts.
   Each attribute includes the list of users which have been delivered
   or read the messages.

   For example - a fetch of a message once there have been some read-
   receipts might look like:























Rosenberg                Expires August 10, 2020               [Page 15]

Internet-Draft                  RIPP Chat                  February 2020


    [{
     "timestamp":"2020-02-01T23:02:26+00:00",
     "creator":"https://example.com/.well-known/ietf-chat/users/8as",
     "uri":"https://example.com/.well-known/ietf-chat/chats/1/m103",

     "read-receipts": {[
      "https://example.com/.well-known/ietf-chat/users/j7t",
      "https://example.com/.well-known/ietf-chat/users/0Y6"]},

     "components" [
       {
        "type":"application/vns.ms-powerpoint",
        "link":"https://example.com/.well-known/ietf-chat/files/aa9w",
        "thumbnail": [
           {
            "uri":"https://example.com/.well-known/ietf-chat/files/9a9kk",
            "page": 1,
            "pages": 2,
            "type": "image/jpeg"
           },
           {
            "uri":"https://example.com/.well-known/ietf-chat/files/-99Hn",
            "page": 2,
            "pages": 2,
            "type": "image/jpeg"
           },

       } ]
    }]



4.6.  Unread Message Counters and Read Markers

   ANother common feature of chat apps is the abiliyt to see the number
   of unread messages in a chat.  Similarly, when a user enters this
   chat, there is frequently a visual indicator showing the boundary
   between the oldest read message, and the oldest unread message.  We
   call this the unread marker.

   This feature is largely driven by the usage of read-receipts
   generated by the client.

   If a chat supports read indicators, the chat object will include an
   additional parameter called "unread-messages".  This represents the
   number of messages in the chat which are beyond the most recent read-
   receipt issued by the user for that chat.  When a client starts up,
   and it fetches the chat object, this parameter will be present and



Rosenberg                Expires August 10, 2020               [Page 16]

Internet-Draft                  RIPP Chat                  February 2020


   the client can render it, even without fetching the actual messages
   in the chat.

   The server can also elect to update this value, and then inform the
   client of the change.  To do that, a client would be running a long-
   running GET to the "chats" resource in the instance.  When the server
   wishest to update the value for one of the unread indicators, it
   sends the client an event for that particular chat.  The client will
   fetch the object and see the new unread counter.  This will happen
   even if the client isnt receiving the messages themself.  This
   approach gives the server a great deal of latitude in how frequently,
   and for which chats, it provides updated unread message counts.

   If the client enters a chat (i.e., it is rendered in the UI), it will
   fetch the messages since the last time it synced, via a GET to the
   messages URI.  The server knows the most recently read message from
   read receipts (which may have been read on another client), and so
   indicates - in the message object - a "last-read" indicator for that
   message which generated the last read receipt.  This provides the
   unread marker capability.

4.7.  Typing Indicators

   Typing indicators are similar to read-receipts.  However, they have
   an expiration which indicates when its typing indicator should be
   removed.  To post a typing indicator to a chat, the client posts to
   the typing indicator resource learned from the chat object itself.


   POST https://example.com/.well-known/ietf-chat/chats/0e87/ti

   {
      "expires":"2020-02-01T23:02:26+00:00",
   }



   The server would respond with a 201 and the Location header field
   contains a pointer to this read-receipt.  That read-receipt resource
   exists for a short while, only until the expiration is passed.

   Clients can receive real-time notifications of typing indicators by
   performing a GET against the "/events" subresource of the typing
   indicators URI.  This will provide the client with the typing
   indicators sent by other clients into the chat.  A client can
   retrieve the current list of non-expired read receipts by performing
   a GET against the typing indicators resource.  Typing indicators are




Rosenberg                Expires August 10, 2020               [Page 17]

Internet-Draft                  RIPP Chat                  February 2020


   not returned in response to a fetch of the current messages in the
   chat.

4.8.  Files in a Chat

   When the "files" attribute is present in the chat object, it means
   that the client can post and retrieve the files uploaded to the chat.

   Files can be uploaded to the chat by posting a message to the chat
   resource that contains a file (either embedded or uploaded to the
   separate files repository of the instance itself), or by performing a
   POST directly to the files URI.  The latter is isomorphic to posting
   a message to the chat containing just a file.

   Performing a GET against the files URI returns the files that are
   available in the chat.  The GET can contain the optional "since" and
   "until" in order to provide re-synchronization.  Results are
   paginated as needed.  The result is a list of file URI.

4.9.  Message Edit and Delete

   A user can delete a message by performing a DELETE against the
   message URI.  This will generate an event to any client performing an
   event against the /events subresource on the messages URI, containing
   the URI of the message that was deleted.  A client receiving this
   notification would perform a GET against this URI and get back a 404,
   indicating it was a deletion.  The message can then be removed from
   the UI.

   When a client retrieves messages by performing a GET against the
   messages URI, any messages which have been deleted are, of course,
   not provided in the response.

   Modifying a message works similarly - the client performs a PUT
   against the message URI.  Other users find out about the change via
   the /events subresource on the messages URI, which provides other
   clients with the URI of the changed message.  The clients would
   perform a GET.  This time, the message is returned but it will be
   marked with an "edited" attribute which indicates by whome and when
   the message was edited, along with the new message content.  Of
   course, when a client performs a GET against the messages URI, it
   receives only the edited version of the message, along with the
   "edited" attribute.








Rosenberg                Expires August 10, 2020               [Page 18]

Internet-Draft                  RIPP Chat                  February 2020


4.10.  Threads

   Threads are modeled as a chat within a chat.  The capability for
   threading in a chat is discovered because the chats JSON object will
   have a "threads" attribute containing the URI to use for retrieving
   threads.

   To create a thread from a message, the client performs a POST against
   the threads URI, and provides a reference to the message:


   POST https://example.com/.well-known/ietf-chat/chats/0e87/th

   {
      "message":"https://example.com/.well-known/ietf-chat/chats/1/m103"
   }



   The server would create the thread, and return a URI.  This URI has
   semantics identical to a chat.  A GET against it will return a
   description of the "chat", including URIs for posting messages, read-
   receipts, and so on.  If the object includes a "threads" URI, it
   means the service supports threads within a thread.  The server can
   control the depth of the threading by deciding when to return a
   "threads" URI and when to not.

   A client can learn about new messages in just the thread by
   performing a GET on the thread's URI.  A GET against the top-level
   messages URI will inform the client about messages in the main chat
   and all threads and subthreads.

4.11.  Pinned Content

   Pinned content in a chat is just a list.  The chat object would
   include a URI, called "pins" in its JSON, which represents this list.
   Using the list processes defined below, a user can add, remove or
   retrieve all of the objects in the list.

5.  Profile, Users and Directory

   A user is represented by a URI, of course, which uniquely identifies
   the user.  An actual human user with accounts on multiple instances
   in multiple domains would have multiple URI, one in each instance and
   domain it is on.

   A user can define their own profile, through the "users" URI on the
   instance itself.  To do this, a user would POST to the users URI, and



Rosenberg                Expires August 10, 2020               [Page 19]

Internet-Draft                  RIPP Chat                  February 2020


   include a body which describes their key attributes.  These include
   firstname, lastname, city, image, email, phone number, and so on.
   Server policy can decide which of these fields the user can set, vs.
   which ones the server obtains through other sources (i.e., email
   generally should not be settable by the client).  The server can
   ignore any attributes that the client cannot set.  The response to
   this POST includes a URI identifying the user themself.  If a system
   only allows the user to have a single profile, the URI returned will
   not change if the user does a subsequent POST.


   POST https://example.com/.well-known/ietf-chat/profs/23

   {
      "firstname":"Jonathan",
      "lastname":"Rosenberg",
      "email":"fake@example.com"
   }



   And the server would reply:

   201 Created
   https://example.com/.well-known/ietf-chat/profs/23/sk9

   {
      "firstname":"Jonathan",
      "lastname":"Rosenberg",
      "email":"jdrosen@example.com"
   }



   Notice that the server has rejected and corrected the email address.
   Of course, a GET of this URI will return the profile for the user.

   A user can find their existing profile by performing a query to the
   users URI with the URI parameter "self".  The resulting JSON object
   provides the current information for the user.  It also contains
   empty values for any profile attributes which the server allows the
   client to set, but which are not yet set.  This allows for profile
   extensibility.

   A client can obtain a list of all of the users in an instance by
   performing a GET against the users URI, with no parameters.  The
   result will of course be paginated, and includes a list, where each
   entry in the list is a "name", "img" and "uri" allowing for the



Rosenberg                Expires August 10, 2020               [Page 20]

Internet-Draft                  RIPP Chat                  February 2020


   client to render the results.  Similarly, to filter, the client can
   perform a query by including a "query" parameter which has a search
   string.

   A special attribute for a user is "guest" which indicates that the
   user in question is a guest.  This tells the client that this user
   exists outside of the instance, and may have reduced privileges in
   this instance.  See the discussion below on guests.

   A client can learn of new, deleted or changed users in their instance
   by performing a GET against the "/events" subresource of the users
   URI.

6.  Lists

   Lists services allow a user to create lists of things.  These can be
   a list of chats for a favorites list, a list of users for a buddy
   list, a list of messages for a favorite messaging list, and so on.

   An instance which supports the lists service includes the URI for
   this service in its instance object.

   To create a list, the user performs a POST to the lists URI.  The
   body is empty.  The server responds with a 201 and the URI for the
   list.

   A GET to the lists resource returns the current lists for that user.
   Some services may support special types of lists, which the user is
   permitted to create.  THis specification defines two well-known list
   types - the "starred" list and the "buddies" list.  When the server
   indicates to the client that there is a "starred-chats" list, it
   indicates this is a list which can contain chats, and the client
   should treat as its list of favorite chats.  The "buddies" is used
   for applications which allow a user to create and maintain a buddy
   list of users that it wishes to track presence for.  The "starred-
   content" list is a list of messages or files that the user wishes to
   remember.

   So for example, when a user performs an initial query on the lists
   resource:











Rosenberg                Expires August 10, 2020               [Page 21]

Internet-Draft                  RIPP Chat                  February 2020


GET https://example.com/.well-known/ietf-chat/lists/23

{
  "starred-chats": "https://example.com/.well-known/ietf-chat/lists/234"
}



   This tells it that the server has a pre-created list for the user,
   its starred-chats.  THe user can use this URI to add or remove users
   to this list.

   To add a user to a list, the client performs a POST against the list
   URI, with a body which has the URI for the resource.  The server
   creates a list entry and returns a URI for this list entry to the
   client, along with its value.  This allows the client to later DELETE
   the entry to remove it.

   The client can create other, non-well-known lists, to facilitate bulk
   operations like presence queries.

7.  Presence

   If the instance description includes the "presence" attribute with a
   corresponding URI, this tells the client that the instance supports
   presence capabilities, and the provided URI can be used for presence.

   A user can set their presence status by performing a POST to the
   presence URI.  This contains a presence object which indicates the
   user's status:


POST https://example.com/.well-known/ietf-chat/pres/23

{
  "status":"busy",
  "expires":"2020-02-01T23:02:26+00:00",
  "alt-text":"In a Meeting"
  "alt-img":"uri":"https://example.com/.well-known/ietf-chat/files/-99Hn"
}



   The mandatory field is "status" which is one of "busy", "away",
   "available" and "dnd".  A client can optionally include an expiration
   value for the state.  Alternative text and an image are also
   permitted.  The server takes this as input and decides what state the




Rosenberg                Expires August 10, 2020               [Page 22]

Internet-Draft                  RIPP Chat                  February 2020


   user should really have.  Similarly, the server can set a user's own
   presence state at any time, using other inputs.

   A user learns about changes to their own presence through the /events
   subresource on the presence URI.

   A client can also retrieve the current status of a single user by
   performing a GET request to the "/presence" subresource of the
   presence URI.  The server immediately sends the current status, and
   as long as the client keeps the request open, returns any changes in
   the state of that specific user:


   GET https://example.com/.well-known/ietf-chat/users/887/presence

   {
     "user":https://example.com/.well-known/ietf-chat/users/887/"
     "status":"available",
   }



   A client can also query for the presence state of a list of users, by
   performing a GET request against the "/presence" subresource of a
   list object.  As with the single user case, the server immediately
   sends the current status of all users in the list, and as long as the
   client keeps the request open, returns any changes in the state of
   that specific user.

   If a server supports presence, it can also include the "presence"
   attribute in any user objects returned to the client, in search
   results or in direct queries.  Presence results as part of search
   output is particularly helpful to allow a client to know who is
   online amongst those returned in a query.

8.  Deep Links

   Deep linking refers to the ability for a client to provide a URI for
   an object (a message, a chat, a user, a file, and on), which can be
   shared via email, chat or whatever, and then accessed via web-
   browser, providing a rendering of the object in question.

   If the server supports deep linking, the object in question will have
   an attribute called "deep-link", which will be an HTTP URI that
   renders the specific object.






Rosenberg                Expires August 10, 2020               [Page 23]

Internet-Draft                  RIPP Chat                  February 2020


9.  Interoperability Use Cases

   This section describes how this protocol can be used to tackle
   several interop use cases.

9.1.  Consumer to Consumer Interop

   Consider interoperability between WhatsApp and iMessage.  A user
   using iMessage creates a group chat, and adds a user that is not an
   iMessage user.  They do this using the guest account creation feature
   described above, and provide the phone number of the user to be
   added.  They would provide the email or phone number for the user.
   If the iMessage service determines that this user is not currently an
   iMessage user, iMessage would send an SMS to the target user.

   This SMS would be received on the mobile phone of the new user.  This
   user has WhatsApp on their phone.  We further assume that mobile OS
   have been upgraded to support registration as teh default handler for
   ietf-chat, as defined by this specification.  When the OS sees an SMS
   containing one of the well-known invitation URI, it removes the SMS
   message from the user's inbox, and passes the URL to the default
   handler.  In this case, WhatsApp has registered itself as said
   handler.  The OS cross launches the handler with this URI.  The
   WhatsApp application would follow the procedures defined above for
   guest access - it would use the URI to obtain a bearer token, then
   query for its list of instances, update its profile into iMessage,
   and get the list of chats it is in within the iMessage service.  In
   this case, it is just the one new one the user was added to.  WIthin
   the WhatsApp application, this would simply be rendered as a new
   chat.

   To allow the WhatsApp client to 'remember' that it has chats on the
   iMessage service, it would perform a POST to the whatsapp instances
   resource, adding the new iMessage instance it has been added to:

     POST whatsapp.com/.well-known/ietf-chat/instances
   {
     "uri" : "https://imessage.com/.well-known/ietf-chat/instances/23",
   }



   In other words, this technique enables interoperability NOT be some
   kind of server to server messaging protocol (ala SMTP or SIP), but
   rather, by automating the creation of guest accounts and using email
   or SMS to actually deliver the bootstrap invitation needed for a
   client to communicate with multiple chat services from multiple




Rosenberg                Expires August 10, 2020               [Page 24]

Internet-Draft                  RIPP Chat                  February 2020


   domains.  To the end users, it looks like there is transparent
   interop between the applications.

9.2.  Intra-Domain Enterprise Chat Federation

   In this use case, a large enterprise has users that are on different
   team chat applications - say, for example, Webex Teams and Slack.
   Consider further that Slack was deployed by a department in the
   company, and subsequently the company deployed Webex Teams for all,
   including users in the department.  However, users within the
   department wish to remain Slack users, in order to keep their chats
   and history.

   In this use case, once the Webex Teams application is rolled out to
   everyone, the Slack service would be updated by the administrator,
   adding a second instance.  This instance however is on Webex Teams.
   The new instance would be learned by all Slack clients through their
   long running GET to the events sub-resource of the "/instances"
   resource.  This would inform the Slack clients of a new instance - in
   this case (say) - example.webex.com/.well-known/ietf-chat/9388k -
   which is the instance URI for the company wide instance.

   The Slack client attempts to query this URI, and is redirected to
   perform an OAuth flow that utilizes the corporate SSO.  As such, the
   user doesnt need to enter any credentials and will end up with an
   OAuth token issued by Webex Teams service.  The Slack client can then
   represent the entire company Webex Teams instance as another "team",
   or, transparently include it within the existign single team used by
   the department.  The latter has the benefit that the end user need
   not switch to a different Slack "team" to see messages from its
   company-wide Webex Teams deployment.

   When a user of the Slack client creates a new chat, the client can
   choose whether to create it on the Slack service or the Webex Teams
   service.  The company can select its default, in this case, Webex
   Teams.  As a result, new chats will all be created on the new service
   deployed company wide, but users will have access to their old
   content on Slack.  This allows them to remain on Slack indefinitely,
   until such time as they are simply no longer using the old chats.

   The same model also allows for cases where there is no company-wide
   solution, but rather a number of departmental services that are
   deployed, with non-overlapping user bases.  Over time, users would
   get invited as guests into the services that they are not a native
   member of, and each user uses the client of their preference.






Rosenberg                Expires August 10, 2020               [Page 25]

Internet-Draft                  RIPP Chat                  February 2020


9.3.  Inter-Company Chat

   ANother use case is when company A has deployed a team chat app, and
   company B has also deployed an app.  Consider the case where they are
   both actually using the same service (though the solution works even
   if they arent)

   The interop starts when a user from company A adds a user in company
   B, by adding their email address to a group chat.  This causes an
   email to be delivered to the user in company B.  The email client for
   the user - say Outlook - is configured to recognize this well-known
   URI and it cross-launches their messaging app and passes the URI.

   The user in B, their client would utilize the URI to bootstrap itself
   as a guest into the instance for company A, and render to the user
   the new chat room that the user was added to.  If the policy of
   company A allows, the user in company B can perform searches, and the
   client would "fork" the search queries to both the instance in its
   own company (B) as well as the instance it just joined in company A,
   merging the results.  This allows for cross-company directory search.

10.  IANA Considerations

   No values are assigned in this document, no registries are created,
   and there is no action assigned to the IANA by this document.

11.  Security Considerations

   This document introduces no new security considerations.  It is a
   process document about changes to the rules for certain corner cases
   in publishing IETF stream RFCs.

12.  Informative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC6120]  Saint-Andre, P., "Extensible Messaging and Presence
              Protocol (XMPP): Core", RFC 6120, DOI 10.17487/RFC6120,
              March 2011, <https://www.rfc-editor.org/info/rfc6120>.

   [RFC6914]  Rosenberg, J., "SIMPLE Made Simple: An Overview of the
              IETF Specifications for Instant Messaging and Presence
              Using the Session Initiation Protocol (SIP)", RFC 6914,
              DOI 10.17487/RFC6914, April 2013,
              <https://www.rfc-editor.org/info/rfc6914>.



Rosenberg                Expires August 10, 2020               [Page 26]

Internet-Draft                  RIPP Chat                  February 2020


   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

Author's Address

   Jonathan Rosenberg (editor)
   Five9
   4000 Executive Parkway #400
   San Ramon, CA  94583
   US

   Email: jdrosen@jdrosen.net






































Rosenberg                Expires August 10, 2020               [Page 27]
