<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>RIPP for Single User Endpoints</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Introduction">
<link href="#rfc.section.3" rel="Chapter" title="3 Overview of Operation">
<link href="#rfc.section.4" rel="Chapter" title="4 Example Use Cases">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Inbound Call Forking">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Answer and Stop Ringing Other Devices">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Remote in Use">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Call Pull">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Call Push">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Select Device">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 3PCC: Place Outbound">
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 3PCC: Answer or Decline Inbound">
<link href="#rfc.section.4.9" rel="Chapter" title="4.9 3PCC: Hangup">
<link href="#rfc.section.4.10" rel="Chapter" title="4.10 3PCC: Move Call">
<link href="#rfc.section.4.11" rel="Chapter" title="4.11 Resiliency: Miss Incoming call">
<link href="#rfc.section.4.12" rel="Chapter" title="4.12 Resiliency: Mid-Call Network Change">
<link href="#rfc.section.4.13" rel="Chapter" title="4.13 Resiliency: Mid-Call Wireless Fade and Recover">
<link href="#rfc.section.4.14" rel="Chapter" title="4.14 Resiliency: Mid-Call Wireless Fade and Move">
<link href="#rfc.section.4.15" rel="Chapter" title="4.15 Resiliency: Mid-Call Wireless Fade and Peer Hangup">
<link href="#rfc.section.4.16" rel="Chapter" title="4.16 Resiliency: Mid-Call Wireless Fade and Server Drop">
<link href="#rfc.section.5" rel="Chapter" title="5 Normative Protocol Specification">
<link href="#rfc.section.6" rel="Chapter" title="6 Syntax">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="9 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Rosenberg, J., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-rosenberg-dispatch-ripp-inbound-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-01-27" />
  <meta name="dct.abstract" content="The Real-Time Internet Peering Protocol (RIPP) defines a technique for establishing, terminating and otherwise managing calls between entities in differing administrative domains. While it can be used for single user devices like an IP phone, it requires the IP phone to have TLS certificates and be publically reachable with a DNS record. This specification remedies this by extending RIPP to enable clients to receive inbound calls through their outbound connection to the server. It also provides basic single-user features such as forking, call push and pull, third-party call controls, and call appearances. It describes techniques for resiliency of calls, especially for mobile clients with spotty network connectivity. " />
  <meta name="description" content="The Real-Time Internet Peering Protocol (RIPP) defines a technique for establishing, terminating and otherwise managing calls between entities in differing administrative domains. While it can be used for single user devices like an IP phone, it requires the IP phone to have TLS certificates and be publically reachable with a DNS record. This specification remedies this by extending RIPP to enable clients to receive inbound calls through their outbound connection to the server. It also provides basic single-user features such as forking, call push and pull, third-party call controls, and call appearances. It describes techniques for resiliency of calls, especially for mobile clients with spotty network connectivity. " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">J. Rosenberg, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Five9</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">January 27, 2020</td>
</tr>
<tr>
<td class="left">Expires: July 30, 2020</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">RIPP for Single User Endpoints<br />
  <span class="filename">draft-rosenberg-dispatch-ripp-inbound-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The Real-Time Internet Peering Protocol (RIPP) defines a technique for establishing, terminating and otherwise managing calls between entities in differing administrative domains. While it can be used for single user devices like an IP phone, it requires the IP phone to have TLS certificates and be publically reachable with a DNS record. This specification remedies this by extending RIPP to enable clients to receive inbound calls through their outbound connection to the server. It also provides basic single-user features such as forking, call push and pull, third-party call controls, and call appearances. It describes techniques for resiliency of calls, especially for mobile clients with spotty network connectivity. </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 30, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Terminology</h1>
<p id="rfc.section.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here. </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Introduction</h1>
<p id="rfc.section.2.p.1">The Real-Time Internet Peering Protocol (RIPP) defines a technique for establishing, terminating and otherwise managing calls between entities in differing administrative domains. It is an application ontop of HTTP/3, and as such has the notion of a client that opens connections and makes requests to a server. In the core RIPP specification, clients can only place outbound calls. Inbound calls are supported by requiring an entity to also run a server. </p>
<p id="rfc.section.2.p.2">While this requirement is appropriate for use cases like SIP trunking, carrier to carrier peering, or other arrangements involving a large number of calls, it is a poor match for single user devices. A single user device is one in which an actual end user would log in and use that device for making and receiving calls. Exampes include desktop softphones, browser based webRTC appications, IP hardphones, and video conferencing endpoints. These devices are often behind a NAT, dont have DNS names, and don't have TLS certificates, all of which are pre-requisiites to run a server. </p>
<p id="rfc.section.2.p.3">Furthermore, an end user may often be logged into multiple such devices, possibly from multiple locations. This introduces additional requirements. Inbound calls need to be forked to all devices, and ring on all of them. A user must be able to answer on one, and stop ringing on the others. SIP <a href="#RFC3261" class="xref">[RFC3261]</a> natively supported these capabilities. However, it lacked other ones which are clearly needed - native support for mobile-based apps which utilize push notifications is one significant example. </p>
<p id="rfc.section.2.p.4">SIP's lack of call state in servers as a built-in feature of the protocol has also meant it couldn't readily support other features truly needed for a system where a user can be logged into multiple devices. These include the ability for one device to see the state of the call, and know on which other device the call is being handled. Another important feature includes the ability to - from any device - end the call, move it to a different device, or on the device the user is sitting on. It also includes basic third party call controls - the ability to initiate or answer a call from one client, but have the media delivered to another. </p>
<p id="rfc.section.2.p.5">To rememdy these challenges this specification provides an extension to RIPP to facilitate multi-user devices. </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Overview of Operation</h1>
<p id="rfc.section.3.p.1">The actual protocol enhancement to RIPP is small. The primary one is enabling a server to inform the client of an inbound call, and to add additional events and supported event directions. The second one is additional behaviors required of clients around handlers.</p>
<p id="rfc.section.3.p.2">To signal usage of this specification, the server includes a new element, "inbound", in its TG description. The format of this element is identical to what it would look like to receive calls on a TG that would have been hosted by the single-user device, had it been able to do so. For example, the following TG describes a single user TG which can handle both outbound and inbound calls:</p>
<pre>
{
  "outbound": {
    "origins" : "+14085551002",
    "destinations" : "*"
  },
  "inbound": {
    "destinations" : "+14085551002",
    "origins" : "*"
  }
}  

    </pre>
<p id="rfc.section.3.p.3">The client will follow RIPP procedures for handler registration. This is analagous to the SIP REGISTER operation. For server to server peering arrangements, the handler represents a particular collection of capabilities on an SBC. When used by single-user devices, it represents each individual device. Consequently, if a user has four IP phones, there would be four handlers created on the server. As specified in RIPP each client needs to remember its handler URI persistently in order to modify it or delete it later on. </p>
<p id="rfc.section.3.p.4">Unlike SIP, wherein a client frequently refreshes its registrtion because it is soft-state, a RIPP client doesn't do this. Handlers are not soft-state, they are hard-state. A server can remove handler at will of course, but it is the responsibility of the client, through events or a query to its own handler URI, to learn of this and create a new one it if needed. Under normal conditions however, the server won't ever remove them. This is because receipt of inbound calls not tied to the existence of a handler, which is a substantially different model than used by SIP. Think of handlers like an inventory of a user's devices, solely for the purpose of an end user selecting amongst them when making or answering a call. As such, a server might delete one after extended inactivity (say, one month). But this is not necessary except to improve the user experience by eliminating old devices when a device list is too long. </p>
<p id="rfc.section.3.p.5">Unlike SIP-outbound, receipt on inbound calls doesnt rely on a client having a persistent connection to receive a call. RIPP does require a persistent connection for timely delivery of call events, but it does not have a functional dependency on it. For example, consider a client which lost its connection to the server for a few seconds, perhaps due to a fade-out in wireless connectivity. If an incoming call arrives at precisely that moment, the client wont receive its event. However, upon recovery of network connectivity, the client re-establishes its connection to the /events resource on the TG, performs the long-lived GET for events, receives an event about the calls in progress, including a new one that it is not aware of. This event includes the URI for the call. It queries the server, learns about the call, sees its state is "proceeding" and direction is "inbound". This tells the client to render the incoming call dialog. It can then answer and proceed with the call as normal. Indeed, the client can be out of network connectivity for as long as the caller is willing to wait for the call to be answered. This makes RIPP quite resilient to wireless network hiccups, network handoffs, and other network challenges which have become commonplace. </p>
<p id="rfc.section.3.p.6">In a similar way, the highly stateful nature of the RIPP server means that RIPP is also more resilient to mid-call drops in connectivity. A client which loses its network connectivity will, of course, fail to receive media, and its peer won't receive any either. To explicitly inform users of this, this specification introduces a new event, "reconnecting", which informs the client that its peer - which can be RIPP or SIP-based - has lost connectivity and reconnect is in progress. There is also a "reconnected" event that is sent to indicate reconnection. A server can determine when to send this based on any policy it so desires. It is used by the client solely for UI purposes. It encourages the end user to wait rather than hanging up. This allows the remote user to recover their network connectivity, or perhaps pull the call to another device. So, for example, a user might be on their call on mobile, lose connectivity when entering their home. They go to their wired PC, which will know about the call, and be able to hit a "pull call here" button or similar, and proceed with the call. </p>
<p id="rfc.section.3.p.7">The support of inbound calls on the TG means that the client can learn about incoming calls by performing a GET to the /events resource on the TG URI, as described in the core RIPP specification. This specification adds a new event, "call", which includes, as a parameter, the URI for the call that is now available to the client. The server will generate this event for both inbound and outbound calls, allowing any client that is retrieving these events to know about new calls.</p>
<p id="rfc.section.3.p.8">In order to receive inbound calls continuously, the client maintains its long-lived GET request to the /events resource. Of course, the client can learn about a new call through other means, such as through mobile push notifications. These need only deliver the call URI to the client, who can then query it and proceed from there.</p>
<p id="rfc.section.3.p.9">Once the client learns of this new call, it performs a GET on the call URI. This will provide the client with the call direction (in this case, inbound), calling party, destination number and most recent event (in this case, proceeding). This allows the client to render UI. </p>
<p id="rfc.section.3.p.10">With call state fetched, the client follows the procedures defined in RIPP, and establishes the signaling and media byways as normal. Once it starts alerting the user, it generates an "alerting" event towards the server. If it wishes to accept the call, it generates an "answered" event towards the server. The "answered" event, when sent by the client, includes a handler URI, which specifies the device on which the client would like the media to be rendered. Normally this will be itself. </p>
<p id="rfc.section.3.p.11">However, the client can specify a different handler. Any authorized client can learn about the handlers for the TG by querying the /handlers endpoint, which returns a list of them. The client can then iterate through them and request their details. It can also receive updates to the set of handlers using the /events resource on the TG. Specifying a different handler enables third-party call control operations. The image, device nickname and other attributes on the handler allow an end user to usefully select the device on which to receive the audio and/or video. </p>
<p id="rfc.section.3.p.12">In the case where, for example, a user answers a call and specifies a handler different from itself, the device associated with that handler needs to know about this. It will learn about this through its signaling byway to the call. It will see an "answered" event for a call, and then an "attaching" event with the handler URI. When the client sees that the handler URI is itself, this tells it that it must render media. To do so, it queries the call URI, which will return to it the directive to use. It also begins to accept media from the server.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Example Use Cases</h1>
<p id="rfc.section.4.p.1">This section outlines example use cases that are enabled by this specification. It is not normative in nature. It merely describes how the new API features defined by this specification can be used by clients to deal with these cases.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Inbound Call Forking</h1>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Answer and Stop Ringing Other Devices</h1>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Remote in Use</h1>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Call Pull</h1>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> Call Push</h1>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> Select Device</h1>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> 3PCC: Place Outbound</h1>
<h1 id="rfc.section.4.8">
<a href="#rfc.section.4.8">4.8.</a> 3PCC: Answer or Decline Inbound</h1>
<h1 id="rfc.section.4.9">
<a href="#rfc.section.4.9">4.9.</a> 3PCC: Hangup</h1>
<h1 id="rfc.section.4.10">
<a href="#rfc.section.4.10">4.10.</a> 3PCC: Move Call</h1>
<h1 id="rfc.section.4.11">
<a href="#rfc.section.4.11">4.11.</a> Resiliency: Miss Incoming call</h1>
<h1 id="rfc.section.4.12">
<a href="#rfc.section.4.12">4.12.</a> Resiliency: Mid-Call Network Change</h1>
<h1 id="rfc.section.4.13">
<a href="#rfc.section.4.13">4.13.</a> Resiliency: Mid-Call Wireless Fade and Recover</h1>
<h1 id="rfc.section.4.14">
<a href="#rfc.section.4.14">4.14.</a> Resiliency: Mid-Call Wireless Fade and Move</h1>
<h1 id="rfc.section.4.15">
<a href="#rfc.section.4.15">4.15.</a> Resiliency: Mid-Call Wireless Fade and Peer Hangup</h1>
<h1 id="rfc.section.4.16">
<a href="#rfc.section.4.16">4.16.</a> Resiliency: Mid-Call Wireless Fade and Server Drop</h1>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Normative Protocol Specification</h1>
<p id="rfc.section.5.p.1">A server that supports inbound calls on its TG MUST include the "inbound" element in its TG description. This MUST include the allowed caller IDs in the "origins" element, and the allowed destinations in the "destinations". </p>
<p id="rfc.section.5.p.2">When a server receives a new inbound call, or places a new outbound call, it MUST send the "call" event to any clients which have a GET query in progress to its TG. This event MUST include the call URI associated with the call that the server is aware of. The server can also utilize push notifications or other techniques outside the scope of this speification to alert clients to new calls. </p>
<p id="rfc.section.5.p.3">The server MUST allow the client to send a "proceeding", "alerting", "answered", "declined", "failed", "noanswer" and "end" events, and take the associated actions on the call.</p>
<p id="rfc.section.5.p.4">A client that answers a call MUST include, as an attribute to the "answered" event, the handler that is to be used for the call. This handler MUST be active and registered to the TG against which the call was received. The server MUST verify this, and if it is not, generate a "handler-invalid" event, with the handler URI from the request as a parameter. In this case, the server MUST NOT consider the call answered. If the handler URI was valid, the server MUST construct a directive per the procedures defined in the core RIPP specification. It MUST then generate an "attaching" event to all listeners, and MUST include the handler URI. It MUST also generate the "answered" event.  </p>
<p id="rfc.section.5.p.5">When a client that had sent an "answered" event receives a "handler-invalid" event including the URI it had generated, it SHOULD refresh its list of handlers, inform the user of the answer failure, and request the user to try again. If the client receives an "attaching" event, and the handler specified matches its own, it SHOULD query the call URI to obtain the directive [[OPEN ISSUE: Not sure I like this, vs. having the client do a POST and have the server construct the directive then. Thinking.]] It MUST initiate signaling and media byways for the call, render incoming media and generate outgoing media for the call. Once the client has sent and received at least one media packet, indicating a successful connection, it MUST generate a "handler-connected" event, including the URI of its handler. As will all call events, this is sent to all listeners. This allows for a reliable handshake for answering calls elsewhere.  </p>
<p id="rfc.section.5.p.6">Similarly, a client MAY, when creating a call, specify a handler in the POST to create the call which is different than itself. When it does that, it follows the procedures defined in the previous paragraph as well.</p>
<p id="rfc.section.5.p.7">A server MAY send, at its own discretion, a "reconnecting" event if it believes the remote side has lost connectivity. It is RECOMMENDED that the server send this event once it has ceased to receive inbound media packets for five seconds. Similarly, a server MUST send a subsequent "reconnected" event once media begins to flow once more. If a server receives a new GET request against the /events resource on the call, it MUST include the "reconnecting" event if it had sent one recently but not yet sent the "reconnected event. This allows a client to obtain the full state of the call when retrieving events.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Syntax</h1>
<p id="rfc.section.6.p.1">This specification outlines the syntax for the new events and TG description. </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> IANA Considerations</h1>
<p id="rfc.section.7.p.1">No values are assigned in this document, no registries are created, and there is no action assigned to the IANA by this document. </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Security Considerations</h1>
<p id="rfc.section.8.p.1">This document introduces no new security considerations. It is a process document about changes to the rules for certain corner cases in publishing IETF stream RFCs.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3261">[RFC3261]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="https://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, DOI 10.17487/RFC3261, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jonathan Rosenberg</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Rosenberg</span>
	  </span>
	</span>
	<span class="org vcardline">Five9</span>
	<span class="adr">
	  <span class="vcardline">4000 Executive Parkway #400</span>

	  <span class="vcardline">
		<span class="locality">San Ramon</span>,  
		<span class="region">CA</span> 
		<span class="code">94583</span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jdrosen@jdrosen.net">jdrosen@jdrosen.net</a></span>

  </address>
</div>
  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Terminology</a>
</li>
<li>2.   <a href="#rfc.section.2">Introduction</a>
</li>
<li>3.   <a href="#rfc.section.3">Overview of Operation</a>
</li>
<li>4.   <a href="#rfc.section.4">Example Use Cases</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Inbound Call Forking</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Answer and Stop Ringing Other Devices</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Remote in Use</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Call Pull</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Call Push</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Select Device</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">3PCC: Place Outbound</a>
</li>
<li>4.8.   <a href="#rfc.section.4.8">3PCC: Answer or Decline Inbound</a>
</li>
<li>4.9.   <a href="#rfc.section.4.9">3PCC: Hangup</a>
</li>
<li>4.10.   <a href="#rfc.section.4.10">3PCC: Move Call</a>
</li>
<li>4.11.   <a href="#rfc.section.4.11">Resiliency: Miss Incoming call</a>
</li>
<li>4.12.   <a href="#rfc.section.4.12">Resiliency: Mid-Call Network Change</a>
</li>
<li>4.13.   <a href="#rfc.section.4.13">Resiliency: Mid-Call Wireless Fade and Recover</a>
</li>
<li>4.14.   <a href="#rfc.section.4.14">Resiliency: Mid-Call Wireless Fade and Move</a>
</li>
<li>4.15.   <a href="#rfc.section.4.15">Resiliency: Mid-Call Wireless Fade and Peer Hangup</a>
</li>
<li>4.16.   <a href="#rfc.section.4.16">Resiliency: Mid-Call Wireless Fade and Server Drop</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Normative Protocol Specification</a>
</li>
<li>6.   <a href="#rfc.section.6">Syntax</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<li>9.   <a href="#rfc.references">Informative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  

</body>
</html>
